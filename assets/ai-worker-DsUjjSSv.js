(function(){"use strict";var d=(r=>(r[r.EMPTY=0]="EMPTY",r[r.BLACK=1]="BLACK",r[r.WHITE=2]="WHITE",r))(d||{}),q=(r=>(r.WAITING="waiting",r.IN_PROGRESS="in_progress",r.PAUSED="paused",r.GAME_OVER="game_over",r))(q||{}),p=(r=>(r.C="C",r.B="B",r.A="A",r.S="S",r.SS="SS",r.SSS="SSS",r))(p||{}),v=(r=>(r.RANDOM="v0",r.GREEDY="v1",r.MINIMAX="v2",r.ADVANCED="v3",r.MINIMAX_EASY="v2a",r.MINIMAX_HARD="v2b",r.MASTER="v3_master",r.BLITZ="v3_blitz",r.CUSTOM="custom",r))(v||{});const E={CORNER:25,EDGE:6,X_SQUARE:-10,C_SQUARE:-6,NORMAL:0},A={B:10,A:18,S:30,SS:45,SSS:60},W={AI_RESPONSE_TIME:{v0:100,v1:1e3,v2:3e3,v3:5e3,v2a:2e3,v2b:4e3,v3_master:1e4,v3_blitz:1500,custom:5e3}},K=r=>r>=0&&r<64,Y=r=>({row:Math.floor(r/8),col:r%8}),D=r=>[0,7,56,63].includes(r),z=r=>{const e=Y(r);return e.row===0||e.row===7||e.col===0||e.col===7},U=r=>[9,14,49,54].includes(r);class w{_isThinking=!1;_shouldStop=!1;_metrics={averageThinkingTime:0,movesPlayed:0,totalNodesEvaluated:0,averageDepth:0,timeoutCount:0,accuracy:0};_thinkingHistory=[];_depthHistory=[];_nodeHistory=[];async selectMove(e,t,i){const s=Date.now(),n=i||this.getDefaultTimeLimit();this._isThinking=!0,this._shouldStop=!1;try{const o=await this.selectMoveImpl(e,t,n),a=Date.now()-s;return this.updateMetrics(o,a,n),{...o,thinkingTime:a}}finally{this._isThinking=!1,this._shouldStop=!1}}getDefaultTimeLimit(){return W.AI_RESPONSE_TIME[this.difficulty]||1e3}shouldStop(e,t){return this._shouldStop||Date.now()-e>=t}updateMetrics(e,t,i){this._thinkingHistory.push(t),e.depth!==void 0&&this._depthHistory.push(e.depth),e.nodesEvaluated!==void 0&&this._nodeHistory.push(e.nodesEvaluated);const s=this._thinkingHistory.length,n=this._thinkingHistory.reduce((c,l)=>c+l,0),o=this._nodeHistory.reduce((c,l)=>c+l,0),a=this._depthHistory.reduce((c,l)=>c+l,0);this._metrics={averageThinkingTime:n/s,movesPlayed:s,totalNodesEvaluated:o,averageDepth:this._depthHistory.length>0?a/this._depthHistory.length:0,timeoutCount:this._metrics.timeoutCount+(t>=i?1:0),accuracy:this.estimateAccuracy()}}estimateAccuracy(){if(this._metrics.movesPlayed===0)return 0;const e=this.getDefaultTimeLimit(),t=this._metrics.averageThinkingTime,i=Math.min(t/e,1),s=this.getBaseAccuracy();return Math.min(s+i*.3,1)}getBaseAccuracy(){switch(this.difficulty){case v.RANDOM:return .1;case v.GREEDY:return .6;case v.MINIMAX:return .8;case v.ADVANCED:return .9;default:return .5}}getPerformanceMetrics(){return{...this._metrics}}resetMetrics(){this._metrics={averageThinkingTime:0,movesPlayed:0,totalNodesEvaluated:0,averageDepth:0,timeoutCount:0,accuracy:0},this._thinkingHistory=[],this._depthHistory=[],this._nodeHistory=[]}isThinking(){return this._isThinking}stopThinking(){this._shouldStop=!0}}class M{static addJitter(e,t=.1){const i=(Math.random()-.5)*2*t;return e+i}static selectWeightedRandom(e,t=1){if(e.length===0)throw new Error("No candidates to select from");if(e.length===1)return e[0];const i=e.map(a=>({...a,weight:Math.exp(a.score/t)})),s=i.reduce((a,c)=>a+c.weight,0),n=Math.random()*s;let o=0;for(const a of i)if(o+=a.weight,n<=o)return a;return i[i.length-1]}static evaluatePositionStability(e,t,i){let s=0;[0,7,56,63].includes(t)&&(s+=10);const n=Math.floor(t/8),o=t%8;(n===0||n===7||o===0||o===7)&&(s+=3);const c=this.getNeighbors(t).filter(l=>e.board[l]===i).length;return s+=c*.5,s}static getNeighbors(e){const t=[],i=Math.floor(e/8),s=e%8;for(let n=-1;n<=1;n++)for(let o=-1;o<=1;o++){if(n===0&&o===0)continue;const a=i+n,c=s+o;a>=0&&a<8&&c>=0&&c<8&&t.push(a*8+c)}return t}static getGamePhase(e){return(e.scores.black+e.scores.white)/64}static calculateMobility(e,t){return e.validMoves.size}static isDangerousPosition(e){return[1,6,8,9,14,15,48,49,54,55,57,62].includes(e)}}class $ extends w{difficulty=v.RANDOM;name="Random AI";description="Selects random valid moves with no strategy";async selectMoveImpl(e,t,i){const s=Date.now(),n=Array.from(e.validMoves.keys());if(n.length===0)throw new Error("No valid moves available");const o=Math.random()*50;await new Promise(u=>setTimeout(u,o));const a=Math.floor(Math.random()*n.length),c=n[a],l=this.evaluateMove(e,c,t);return{position:c,confidence:.1,evaluation:l,thinkingTime:Date.now()-s,depth:0,nodesEvaluated:n.length}}evaluateMove(e,t,i){const s=e.validMoves.get(t)||[];let n=0;return[0,7,56,63].includes(t)?n+=25:this.isEdgePosition(t)?n+=6:[9,14,49,54].includes(t)&&(n-=10),n+=s.length,n+=M.addJitter(0,.5),n}isEdgePosition(e){const t=Math.floor(e/8),i=e%8;return t===0||t===7||i===0||i===7}}class j extends w{difficulty=v.RANDOM;name="Smart Random AI";description="Random moves but avoids obviously terrible positions";async selectMoveImpl(e,t,i){const s=Date.now(),n=Array.from(e.validMoves.keys());if(n.length===0)throw new Error("No valid moves available");const o=n.filter(T=>[0,7,56,63].includes(T)),a=n.filter(T=>this.isEdgePosition(T)&&![0,7,56,63].includes(T)&&!this.isXSquare(T)),c=n.filter(T=>[9,14,49,54].includes(T)),l=n.filter(T=>!o.includes(T)&&!a.includes(T)&&!c.includes(T));let u,h;o.length>0?(u=o,h="corner"):a.length>0?(u=a,h="safe_edge"):l.length>0?(u=l,h="normal"):(u=c,h="x_square");const m=Math.random()*75;await new Promise(T=>setTimeout(T,m));const f=Math.floor(Math.random()*u.length),g=u[f],B=this.evaluateMove(e,g,t),Te=this.getConfidenceForMoveType(h);return{position:g,confidence:Te,evaluation:B,thinkingTime:Date.now()-s,depth:1,nodesEvaluated:n.length}}evaluateMove(e,t,i){const s=e.validMoves.get(t)||[];let n=0;return[0,7,56,63].includes(t)?n+=25:this.isEdgePosition(t)?n+=6:[9,14,49,54].includes(t)&&(n-=10),n+=s.length,n}isEdgePosition(e){const t=Math.floor(e/8),i=e%8;return t===0||t===7||i===0||i===7}isXSquare(e){return[9,14,49,54].includes(e)}getConfidenceForMoveType(e){switch(e){case"corner":return .8;case"safe_edge":return .6;case"normal":return .3;case"x_square":return .1;default:return .2}}}const X={pure(){return new $},smart(){return new j}},x=r=>{if(!K(r))throw new Error(`Invalid position: ${r}`);return{row:Math.floor(r/8),col:r%8}},L=(r,e,t)=>{if(r[e]!==d.EMPTY)return{isValid:!1,flippedPositions:[],reason:"Position is already occupied"};if(e<0||e>=64)return{isValid:!1,flippedPositions:[],reason:"Position is outside the board"};const i=Z(r,e,t);return i.length===0?{isValid:!1,flippedPositions:[],reason:"Move does not flip any opponent pieces"}:{isValid:!0,flippedPositions:i}},Z=(r,e,t)=>{const i=[],s=t===d.BLACK?d.WHITE:d.BLACK,n=[{row:-1,col:0},{row:-1,col:1},{row:0,col:1},{row:1,col:1},{row:1,col:0},{row:1,col:-1},{row:0,col:-1},{row:-1,col:-1}],o=x(e);for(const a of n){const c=F(r,o,a,t,s);i.push(...c)}return i};function F(r,e,t,i,s){const n=[];let o=e.row+t.row,a=e.col+t.col;for(;o>=0&&o<8&&a>=0&&a<8;){const c=o*8+a,l=r[c];if(l===s)n.push(c);else return l===i?n.length>0?n:[]:[];o+=t.row,a+=t.col}return[]}const S=(r,e)=>{const t=new Map;for(let i=0;i<64;i++)if(r[i]===d.EMPTY){const s=L(r,i,e);s.isValid&&t.set(i,s.flippedPositions)}return t},Q=(r,e,t,i)=>{const s=new Uint8Array(r);s[e]=t;for(const n of i)s[n]=t;return s},N=r=>[0,7,56,63].includes(r),G=r=>{const e=x(r);return e.row===0||e.row===7||e.col===0||e.col===7},J=r=>[9,14,49,54].includes(r),ee=r=>[1,6,8,15,48,55,57,62].includes(r),te=(r,e,t)=>{const i=L(r,e,t);if(!i.isValid)return{playerMobility:0,opponentMobility:0};const s=Q(r,e,t,i.flippedPositions),n=t===d.BLACK?d.WHITE:d.BLACK,o=S(s,t),a=S(s,n);return{playerMobility:o.size,opponentMobility:a.size}},H=(r,e,t)=>{let i=0;const s=x(e);if(N(e))return 10;G(e)&&(i+=3);const n=[{row:-1,col:0},{row:-1,col:1},{row:0,col:1},{row:1,col:1},{row:1,col:0},{row:1,col:-1},{row:0,col:-1},{row:-1,col:-1}];let o=0;for(const a of n){const c=s.row+a.row,l=s.col+a.col;if(c>=0&&c<8&&l>=0&&l<8){const u=c*8+l;r[u]===t&&o++}}return i+=Math.floor(o/2),i},ie=(r,e,t,i)=>{const s=se(r,e,t,i),n=ae(s.total);return{points:s.total,grade:n,breakdown:Object.freeze(s)}},se=(r,e,t,i)=>{const s=ne(e),n=i.length,o=oe(r,e,t,i),a=re(r,e,t);let c=s+n+o;const l=Math.max(0,Math.floor(c+a));return{positionValue:s,flippedCount:n,stabilityBonus:o,mobilityFactor:a,total:l}},ne=r=>N(r)?E.CORNER:J(r)?E.X_SQUARE:ee(r)?E.C_SQUARE:G(r)?E.EDGE:E.NORMAL,oe=(r,e,t,i)=>{let s=0;const n=H(r,e,t);s+=n;for(const o of i){const a=H(r,o,t);s+=Math.floor(a/2)}return s},re=(r,e,t)=>{const i=te(r,e,t);return i.playerMobility-i.opponentMobility},ae=r=>r>=A.SSS?p.SSS:r>=A.SS?p.SS:r>=A.S?p.S:r>=A.A?p.A:r>=A.B?p.B:p.C,O=(r,e,t)=>{const i=[];for(const[s,n]of e.entries()){const o=ie(r,s,t,[...n]);i.push({position:s,score:o,flippedPositions:[...n]})}return i.sort((s,n)=>n.score.points-s.score.points)},ce=r=>{if(r.length===0)return null;let e=r[0];for(const t of r)t.score.points>e.score.points&&(e=t);return e};class le extends w{difficulty=v.GREEDY;name="Greedy AI";description="Selects moves with highest immediate score";async selectMoveImpl(e,t,i){const s=Date.now(),n=O(e.board,new Map(e.validMoves),t);if(n.length===0)throw new Error("No valid moves available");const a=Math.min(500+Math.random()*300,i*.8)-(Date.now()-s);a>0&&await new Promise(u=>setTimeout(u,a));const c=ce(n);if(!c)throw new Error("Could not determine best move");const l=this.calculateConfidence(n,c);return{position:c.position,confidence:l,evaluation:c.score.points,thinkingTime:Date.now()-s,depth:1,nodesEvaluated:n.length}}calculateConfidence(e,t){if(e.length===1)return .9;let i=.3;switch(t.score.grade){case p.S:i=.95;break;case p.A:i=.8;break;case p.B:i=.6;break;case p.C:i=.3;break}const s=[...e].sort((n,o)=>o.score.points-n.score.points);if(s.length>1){const n=s[0].score.points-s[1].score.points;n>15?i+=.15:n>5?i+=.05:i-=.1}return Math.max(.1,Math.min(.95,i))}}class ue extends w{difficulty=v.GREEDY;name="Enhanced Greedy AI";description="Greedy with additional strategic considerations";async selectMoveImpl(e,t,i){const s=Date.now(),n=O(e.board,new Map(e.validMoves),t);if(n.length===0)throw new Error("No valid moves available");const o=n.map(g=>({...g,enhancedScore:this.calculateEnhancedScore(e,g,t)}));o.sort((g,B)=>B.enhancedScore-g.enhancedScore);const c=o[0].enhancedScore*.9,l=o.filter(g=>g.enhancedScore>=c),u=M.selectWeightedRandom(l.map(g=>({...g,score:g.enhancedScore})),2),m=Math.min(600+Math.random()*400,i*.9)-(Date.now()-s);m>0&&await new Promise(g=>setTimeout(g,m));const f=this.calculateEnhancedConfidence(l,u);return{position:u.position,confidence:f,evaluation:u.enhancedScore,thinkingTime:Date.now()-s,depth:1,nodesEvaluated:n.length}}calculateEnhancedScore(e,t,i){let s=t.score.points;const n=M.getGamePhase(e);n>.7?s+=t.flippedPositions.length*2:n<.3&&M.isDangerousPosition(t.position)&&(s-=5);const o=M.evaluatePositionStability(e,t.position,i);s+=o;const a=i===d.BLACK?d.WHITE:d.BLACK;return M.calculateMobility(e,a)<3&&(s+=2),s}calculateEnhancedConfidence(e,t){let i=.6;if(e.length===1?i=.9:e.length<=3&&(i=.8),t.score?.grade)switch(t.score.grade){case p.S:i=Math.max(i,.9);break;case p.A:i=Math.max(i,.75);break;case p.B:i=Math.max(i,.6);break}return Math.max(.2,Math.min(.95,i))}}class de extends w{difficulty=v.GREEDY;name="Adaptive Greedy AI";description="Greedy AI that adapts strategy to game phase and score";async selectMoveImpl(e,t,i){const s=Date.now(),n=O(e.board,new Map(e.validMoves),t);if(n.length===0)throw new Error("No valid moves available");const o=this.determineStrategy(e,t),a=n.map(f=>({...f,strategicScore:this.calculateStrategicScore(e,f,t,o)}));a.sort((f,g)=>g.strategicScore-f.strategicScore);const c=this.getSelectionTemperature(o),l=a.slice(0,Math.min(5,a.length)),u=M.selectWeightedRandom(l.map(f=>({...f,score:f.strategicScore})),c),m=this.calculateAdaptiveThinkingTime(e,n.length,o,i)-(Date.now()-s);return m>0&&await new Promise(f=>setTimeout(f,m)),{position:u.position,confidence:this.calculateAdaptiveConfidence(o,u,l),evaluation:u.strategicScore,thinkingTime:Date.now()-s,depth:1,nodesEvaluated:n.length}}determineStrategy(e,t){const i=M.getGamePhase(e),s=t===d.BLACK?e.scores.black:e.scores.white,n=t===d.BLACK?e.scores.white:e.scores.black,o=s-n,a=e.validMoves.size;return i>.8?o>0?"endgame_ahead":"endgame_behind":i>.4?o>5?"consolidate":o<-5?"aggressive":a<3?"careful":"balanced":a>8?"opportunistic":"cautious"}calculateStrategicScore(e,t,i,s){let n=t.score.points;switch(M.getGamePhase(e),s){case"endgame_ahead":n+=t.flippedPositions.length*3;break;case"endgame_behind":n+=t.flippedPositions.length*4,(t.score.grade===p.A||t.score.grade===p.S)&&(n+=10);break;case"aggressive":(t.score.grade===p.A||t.score.grade===p.S)&&(n+=8),n+=t.flippedPositions.length*2;break;case"consolidate":[0,7,56,63].includes(t.position)&&(n+=10),M.isDangerousPosition(t.position)&&(n-=8);break;case"careful":M.isDangerousPosition(t.position)&&(n-=15),n+=M.evaluatePositionStability(e,t.position,i)*2;break;case"opportunistic":t.score.grade===p.S&&(n+=15);break;case"cautious":M.isDangerousPosition(t.position)&&(n-=10);break}return n}getSelectionTemperature(e){switch(e){case"aggressive":case"endgame_behind":return 1.5;case"careful":case"consolidate":return 3;default:return 2}}calculateAdaptiveThinkingTime(e,t,i,s){let n=400;switch(t>8&&(n+=200),t<3&&(n+=100),i){case"endgame_ahead":case"endgame_behind":n+=300;break;case"careful":n+=200;break;case"opportunistic":n-=100;break}return n+=Math.random()*200,Math.min(n,s*.9)}calculateAdaptiveConfidence(e,t,i){let s=.7;switch(e){case"consolidate":case"endgame_ahead":s=.8;break;case"aggressive":case"endgame_behind":s=.6;break;case"careful":s=.75;break}return t.score?.grade===p.S?s=Math.min(.95,s+.15):t.score?.grade===p.A&&(s=Math.min(.9,s+.1)),i.length>4&&(s-=.1),Math.max(.2,s)}}const V={standard(){return new le},enhanced(){return new ue},adaptive(){return new de}},y={POSITION_VALUE:1,MOBILITY:2,STABILITY:3,CORNER_CONTROL:5,EDGE_CONTROL:1.5,POTENTIAL_MOBILITY:1,PARITY:.5,ENDGAME_MATERIAL:10},C=[100,-20,10,5,5,10,-20,100,-20,-50,-2,-2,-2,-2,-50,-20,10,-2,16,2,2,16,-2,10,5,-2,2,1,1,2,-2,5,5,-2,2,1,1,2,-2,5,10,-2,16,2,2,16,-2,10,-20,-50,-2,-2,-2,-2,-50,-20,100,-20,10,5,5,10,-20,100],he=[4,0,3,2,2,3,0,4,0,0,1,1,1,1,0,0,3,1,2,1,1,2,1,3,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,2,3,1,2,1,1,2,1,3,0,0,1,1,1,1,0,0,4,0,3,2,2,3,0,4];class k{static evaluatePosition(e,t){const i=e.board,s=t===d.BLACK?d.WHITE:d.BLACK,n=this.evaluatePositionValue(i,t,s),o=this.evaluateMobility(e,t,s),a=this.evaluateStability(i,t,s),c=this.evaluateCornerControl(i,t,s),l=this.evaluateEdgeControl(i,t,s),u=this.evaluatePotentialMobility(i,t,s),h=this.evaluateParity(i,t,s),m=this.evaluateMaterial(i,t,s);return{totalScore:n*y.POSITION_VALUE+o*y.MOBILITY+a*y.STABILITY+c*y.CORNER_CONTROL+l*y.EDGE_CONTROL+u*y.POTENTIAL_MOBILITY+h*y.PARITY+m*y.ENDGAME_MATERIAL,breakdown:{positionValue:n,mobility:o,stability:a,cornerControl:c,edgeControl:l,potentialMobility:u,parity:h,material:m}}}static evaluatePositionValue(e,t,i){let s=0;for(let n=0;n<64;n++){const o=e[n];o===t?s+=C[n]??0:o===i&&(s-=C[n]??0)}return s}static evaluateMobility(e,t,i){const s=e.currentPlayer===t?e.validMoves.size:0,n=e.currentPlayer===i?e.validMoves.size:0;return s+n===0?0:(s-n)/(s+n)*100}static evaluateStability(e,t,i){let s=0,n=0;for(let o=0;o<64;o++){const a=e[o],c=this.calculatePieceStability(e,o);a===t?s+=c:a===i&&(n+=c)}return s-n}static calculatePieceStability(e,t){const i=e[t];if(i===d.EMPTY||i===void 0)return 0;let s=he[t]??0;if(D(t))return s+10;const n=[-9,-8,-7,-1,1,7,8,9];let o=0;for(const a of n)this.isDirectionStable(e,t,a,i)&&o++;return s+o}static isDirectionStable(e,t,i,s){const n=t+i,o=t-i;return n<0||n>=64||o<0||o>=64?!0:e[n]===s||e[o]===s}static evaluateCornerControl(e,t,i){const s=[0,7,56,63];let n=0,o=0;for(const a of s)e[a]===t?n++:e[a]===i&&o++;return(n-o)*25}static evaluateEdgeControl(e,t,i){let s=0,n=0;for(let o=0;o<64;o++)z(o)&&!D(o)&&(e[o]===t?s++:e[o]===i&&n++);return s-n}static evaluatePotentialMobility(e,t,i){let s=0,n=0;for(let o=0;o<64;o++)if(e[o]===d.EMPTY){const a=this.isAdjacentToColor(e,o,t),c=this.isAdjacentToColor(e,o,i);a&&s++,c&&n++}return s-n}static isAdjacentToColor(e,t,i){const s=[-9,-8,-7,-1,1,7,8,9];for(const n of s){const o=t+n;if(o>=0&&o<64&&e[o]===i)return!0}return!1}static evaluateParity(e,t,i){let s=0;for(let n=0;n<64;n++)e[n]===d.EMPTY&&s++;return s%2===1?1:-1}static evaluateMaterial(e,t,i){let s=0,n=0,o=0;for(let c=0;c<64;c++){const l=e[c];l===t?s++:l===i?n++:o++}const a=o<16?2:.1;return(s-n)*a}static quickEvaluate(e,t,i,s){let n=0;return n+=C[t]??0,n+=s.length*5,D(t)&&(n+=50),U(t)&&(n-=25),n}static getGamePhase(e){let t=0;for(let i=0;i<64;i++)e[i]===d.EMPTY&&t++;return t>40?"opening":t>16?"midgame":"endgame"}}k.evaluatePosition;const me=k.quickEvaluate;k.getGamePhase;class _{static fromGameState(e){const t=e.gameStatus===q.GAME_OVER||e.gameOver===!0||e.validMoves.size===0;return{board:new Uint8Array(e.board),currentPlayer:e.currentPlayer,validMoves:new Map(e.validMoves),scores:{...e.scores},gameOver:t,consecutivePasses:e.consecutivePasses||0}}static makeMove(e,t){const i=e.validMoves.get(t);if(!i)return null;const s=new Uint8Array(e.board);s[t]=e.currentPlayer;for(const u of i)s[u]=e.currentPlayer;const n=e.currentPlayer===d.BLACK?d.WHITE:d.BLACK,o=this.calculateScores(s),a=S(s,n);let c=0,l=!1;if(a.size===0){const u=n===d.BLACK?d.WHITE:d.BLACK,h=S(s,u);if(h.size===0)l=!0,c=2;else return c=1,{board:s,currentPlayer:u,validMoves:h,scores:o,gameOver:!1,consecutivePasses:c}}return{board:s,currentPlayer:n,validMoves:a,scores:o,gameOver:l,consecutivePasses:c}}static makePass(e){const t=e.currentPlayer===d.BLACK?d.WHITE:d.BLACK,i=S(e.board,t),s=e.consecutivePasses+1;return{board:e.board,currentPlayer:t,validMoves:i,scores:e.scores,gameOver:s>=2||i.size===0,consecutivePasses:s}}static calculateScores(e){let t=0,i=0;for(let s=0;s<e.length;s++)e[s]===d.BLACK?t++:e[s]===d.WHITE&&i++;return{black:t,white:i}}static getAllPossibleMoves(e){const t=[];for(const i of e.validMoves.keys()){const s=this.makeMove(e,i);s&&t.push({move:i,newState:s})}return t}static isEndgame(e){let t=0;for(let i=0;i<e.board.length;i++)e.board[i]===d.EMPTY&&t++;return t<=16}static isOpening(e){let t=0;for(let i=0;i<e.board.length;i++)e.board[i]!==d.EMPTY&&t++;return t<=12}static getGamePhaseRatio(e){let t=0;for(let i=0;i<e.board.length;i++)e.board[i]!==d.EMPTY&&t++;return Math.min(1,(t-4)/60)}static getStateHash(e){return`${Array.from(e.board).join("")}_${e.currentPlayer}_${e.consecutivePasses}`}static statesEqual(e,t){if(e.currentPlayer!==t.currentPlayer||e.consecutivePasses!==t.consecutivePasses)return!1;for(let i=0;i<e.board.length;i++)if(e.board[i]!==t.board[i])return!1;return!0}static copyState(e){return{board:new Uint8Array(e.board),currentPlayer:e.currentPlayer,validMoves:new Map(e.validMoves),scores:{...e.scores},gameOver:e.gameOver,consecutivePasses:e.consecutivePasses}}static getStateInfo(e){let t=0,i=0,s=0;for(let o=0;o<e.board.length;o++)switch(e.board[o]){case d.BLACK:t++;break;case d.WHITE:i++;break;case d.EMPTY:s++;break}let n;return s>40?n="opening":s>16?n="midgame":n="endgame",{pieceCount:{black:t,white:i,empty:s},gamePhase:n,mobilityCount:e.validMoves.size}}static validateState(e){try{if(e.board.length!==64||e.currentPlayer!==d.BLACK&&e.currentPlayer!==d.WHITE)return!1;const t=this.calculateScores(e.board);if(t.black!==e.scores.black||t.white!==e.scores.white)return!1;for(const[i,s]of e.validMoves.entries())if(i<0||i>=64||e.board[i]!==d.EMPTY)return!1;return!0}catch{return!1}}}_.fromGameState,_.makeMove,_.makePass,_.getAllPossibleMoves;class b extends w{difficulty=v.MINIMAX;name="Minimax AI";description="Advanced AI using minimax with alpha-beta pruning";_config;_transpositionTable=new Map;_killerMoves=[];_historyTable=new Map;_nodesEvaluated=0;_startTime=0;constructor(e={}){super(),this._config={maxDepth:6,maxTime:3e3,useIterativeDeepening:!0,useTranspositionTable:!0,useMoveOrdering:!0,aspirationWindow:50,...e};for(let t=0;t<=this._config.maxDepth;t++)this._killerMoves[t]=[]}async selectMoveImpl(e,t,i){this._startTime=Date.now(),this._nodesEvaluated=0;const s=Math.min(i,this._config.maxTime),n=Array.from(e.validMoves.keys());if(n.length===0)throw new Error("No valid moves available");if(n.length===1)return{position:n[0],confidence:1,evaluation:0,thinkingTime:Date.now()-this._startTime,depth:0,nodesEvaluated:1};let o;this._config.useIterativeDeepening?o=await this.iterativeDeepening(e,t,s):o=await this.search(e,t,this._config.maxDepth,s);const a=this.calculateConfidence(o,n.length);return{position:o.bestMove,confidence:a,evaluation:o.score,thinkingTime:o.timeElapsed,depth:o.depth,nodesEvaluated:o.nodesEvaluated}}async iterativeDeepening(e,t,i){let s={score:-1/0,bestMove:Array.from(e.validMoves.keys())[0],depth:1,nodesEvaluated:0,timeElapsed:0,terminated:!1},n=0,o=-1/0,a=1/0;for(let c=1;c<=this._config.maxDepth&&!(Date.now()-this._startTime>=i*.9);c++){this._config.aspirationWindow&&c>2&&(o=n-this._config.aspirationWindow,a=n+this._config.aspirationWindow);try{const l=await this.minimaxSearch(e,c,o,a,!0,t,i);if(l.score>-1/0&&(s={score:l.score,bestMove:l.bestMove,depth:c,nodesEvaluated:this._nodesEvaluated,timeElapsed:Date.now()-this._startTime,terminated:!1},n=l.score),this._config.aspirationWindow&&(l.score<=o||l.score>=a)){const u=await this.minimaxSearch(e,c,-1/0,1/0,!0,t,i);u.score>-1/0&&(s={score:u.score,bestMove:u.bestMove,depth:c,nodesEvaluated:this._nodesEvaluated,timeElapsed:Date.now()-this._startTime,terminated:!1})}}catch{break}if(Math.abs(s.score)>1e3)break}return s}async search(e,t,i,s){const n=await this.minimaxSearch(e,i,-1/0,1/0,!0,t,s);return{score:n.score,bestMove:n.bestMove,depth:i,nodesEvaluated:this._nodesEvaluated,timeElapsed:Date.now()-this._startTime,terminated:n.score===-1/0}}async minimaxSearch(e,t,i,s,n,o,a){if(this._nodesEvaluated++,Date.now()-this._startTime>=a)return{score:-1/0};if(this._config.useTranspositionTable){const h=this.lookupTransposition(e,t);if(h){if(h.flag==="exact")return{score:h.score,bestMove:h.bestMove};if(h.flag==="lower"&&h.score>=s)return{score:h.score,bestMove:h.bestMove};if(h.flag==="upper"&&h.score<=i)return{score:h.score,bestMove:h.bestMove}}}if(t===0||e.validMoves.size===0){const h="board"in e&&"scores"in e&&"currentPlayer"in e?e:_.fromGameState(e),m={board:h.board,currentPlayer:h.currentPlayer,validMoves:h.validMoves,scores:h.scores,gameOver:h.gameOver};return{score:k.evaluatePosition(m,o).totalScore}}const c=this.getOrderedMoves(e,t,o);let l,u=n?-1/0:1/0;for(const h of c){const m=this.makeMove(e,h);if(!m)continue;const f=await this.minimaxSearch(m,t-1,i,s,!n,o,a);if(n?(f.score>u&&(u=f.score,l=h),i=Math.max(i,u)):(f.score<u&&(u=f.score,l=h),s=Math.min(s,u)),s<=i){this.updateKillerMoves(h,t);break}}return this._config.useTranspositionTable&&this.storeTransposition(e,t,u,l,i,s),{score:u,bestMove:l}}getOrderedMoves(e,t,i){const s=Array.from(e.validMoves.keys());if(!this._config.useMoveOrdering)return s;const n=s.map(o=>{const a=e.validMoves.get(o)||[],c=me(e.board,o,i,[...a]);let l=0;this._killerMoves[t]&&this._killerMoves[t].includes(o)&&(l+=1e3);const u=`${o}_${i}`,h=this._historyTable.get(u)||0;return l+=h,{move:o,score:c+l}});return n.sort((o,a)=>a.score-o.score),n.map(o=>o.move)}makeMove(e,t){const i="board"in e&&"validMoves"in e&&"currentPlayer"in e?e:_.fromGameState(e);return _.makeMove(i,t)}updateKillerMoves(e,t){this._killerMoves[t]||(this._killerMoves[t]=[]);const i=this._killerMoves[t];i.includes(e)||(i.unshift(e),i.length>2&&i.pop())}lookupTransposition(e,t){const i=this.getTranspositionKey(e),s=this._transpositionTable.get(i);return s&&s.depth>=t?s:null}storeTransposition(e,t,i,s,n,o){const a=this.getTranspositionKey(e);let c;i<=n?c="upper":i>=o?c="lower":c="exact",this._transpositionTable.set(a,{depth:t,score:i,flag:c,bestMove:s,timestamp:Date.now()}),this._transpositionTable.size>1e5&&this.cleanupTranspositionTable()}getTranspositionKey(e){return`${Array.from(e.board).join("")}_${e.currentPlayer}`}cleanupTranspositionTable(){const t=Date.now()-3e5;for(const[i,s]of this._transpositionTable.entries())s.timestamp<t&&this._transpositionTable.delete(i)}calculateConfidence(e,t){let i=.7;return i+=Math.min(e.depth/10,.2),e.terminated&&(i-=.3),Math.abs(e.score)>500&&(i+=.2),t>8&&(i-=.1),Math.max(.1,Math.min(.95,i))}getConfig(){return{...this._config}}setConfig(e){this._config={...this._config,...e}}clearCaches(){this._transpositionTable.clear(),this._historyTable.clear();for(let e=0;e<=this._config.maxDepth;e++)this._killerMoves[e]=[]}}const R={basic(){return new b({maxDepth:4,maxTime:2e3,useIterativeDeepening:!0})},intermediate(){return new b({maxDepth:6,maxTime:3e3,useIterativeDeepening:!0,useTranspositionTable:!0})},advanced(){return new b({maxDepth:8,maxTime:5e3,useIterativeDeepening:!0,useTranspositionTable:!0,useMoveOrdering:!0,aspirationWindow:50})},custom(r){return new b(r)}};class fe{_entries=new Map;_sequences=[];_maxDepth;constructor(e=12){this._maxDepth=e,this.initializeOpeningDatabase()}getOpeningMove(e){const t=this.generateKey(e),i=this._entries.get(t);if(!i||i.length===0)return null;const s=i.filter(o=>e.validMoves.has(o.position));return s.length===0?null:s.reduce((o,a)=>{const c=o.score*.7+o.winRate*.3;return a.score*.7+a.winRate*.3>c?a:o}).position}getOpeningMoves(e){const t=this.generateKey(e);return(this._entries.get(t)||[]).filter(s=>e.validMoves.has(s.position))}hasOpeningMove(e){const t=this.generateKey(e),i=this._entries.get(t);return i?i.some(s=>e.validMoves.has(s.position)):!1}getOpeningDepth(e){const i=e.scores.black+e.scores.white-4;return Math.min(i,this._maxDepth)}getSequence(e){return this._sequences.find(t=>t.name===e)||null}getAllSequences(){return[...this._sequences]}initializeOpeningDatabase(){this.addOpening("eeeeeeeeeeeeeeeeeeeeeeeeeeee12212100eeeeeeeeeeeeeeeeeeeeeeeeeeee",[{pos:19,score:0,freq:.3,win:.52,comment:"Tiger"},{pos:26,score:0,freq:.25,win:.51,comment:"Rabbit"},{pos:37,score:0,freq:.25,win:.51,comment:"Cat"},{pos:44,score:0,freq:.2,win:.5,comment:"Ox"}]),this.addOpening("eeeeeeeeeeeeeeeeeeee1eeeeee12111100eeeeeeeeeeeeeeeeeeeeeeeeeeee",[{pos:18,score:2,freq:.4,win:.53,comment:"Tiger main line"},{pos:20,score:0,freq:.3,win:.52,comment:"Tiger solid"},{pos:11,score:-1,freq:.2,win:.49,comment:"Tiger passive"},{pos:34,score:1,freq:.1,win:.51,comment:"Tiger counter"}]),this.addOpening("eeeeeeeeeeeeeeeeeeeeeeeeeeee11112100eeeeeeeeeeeeeeeeeeeeeeeeeeee",[{pos:18,score:1,freq:.35,win:.52,comment:"Rabbit main"},{pos:19,score:1,freq:.35,win:.52,comment:"Rabbit parallel"},{pos:25,score:0,freq:.2,win:.5,comment:"Rabbit edge"},{pos:33,score:-1,freq:.1,win:.48,comment:"Rabbit weak"}]),this.addOpening("eeeeeeeeeeeeeeeeeeeeeeeeeeee12211100eeeee1eeeeeeeeeeeeeeeeeeeeee",[{pos:45,score:2,freq:.4,win:.54,comment:"Cat main line"},{pos:43,score:1,freq:.3,win:.52,comment:"Cat solid"},{pos:29,score:0,freq:.2,win:.5,comment:"Cat transpose"},{pos:52,score:-1,freq:.1,win:.48,comment:"Cat edge"}]),this.addOpening("eeeeeeeeeeeeeeeeeeeeeeeeeeee12211100eeeeeeeeeeee1eeeeeeeeeeeeeee",[{pos:43,score:1,freq:.4,win:.52,comment:"Ox main"},{pos:45,score:1,freq:.3,win:.52,comment:"Ox symmetric"},{pos:37,score:0,freq:.2,win:.5,comment:"Ox transpose"},{pos:52,score:-1,freq:.1,win:.48,comment:"Ox passive"}]),this.addDeepSequences(),this.addNamedSequences()}addDeepSequences(){this.addOpening("eeeeeeeeeeeeeeeeee11eeeeeee11111100eeeeeeeeeeeeeeeeeeeeeeeeeeee",[{pos:10,score:3,freq:.5,win:.55,comment:"Tiger sharp"},{pos:12,score:2,freq:.3,win:.53,comment:"Tiger solid"},{pos:25,score:1,freq:.2,win:.51,comment:"Tiger positional"}]),this.addOpening("eeeeeeee11eeeeeeee11eeeeeee11111100eeeeeeeeeeeeeeeeeeeeeeeeeeee",[{pos:9,score:2,freq:.4,win:.54,comment:"Advanced tiger"},{pos:17,score:2,freq:.3,win:.53,comment:"Edge control"},{pos:24,score:1,freq:.3,win:.52,comment:"Center play"}])}addNamedSequences(){this._sequences.push({name:"Tiger Opening",description:"Aggressive opening focusing on quick development",moves:[19,18,10],evaluation:2,isMainLine:!0},{name:"Rabbit Opening",description:"Balanced opening with flexible development",moves:[26,18,19],evaluation:1,isMainLine:!0},{name:"Cat Defense",description:"Solid defensive setup",moves:[37,45,43],evaluation:1,isMainLine:!0},{name:"Ox System",description:"Conservative approach with emphasis on stability",moves:[44,43,45],evaluation:0,isMainLine:!0},{name:"Buffalo Opening",description:"Hypermodern approach delaying central confrontation",moves:[19,20,12],evaluation:1,isMainLine:!1},{name:"Snake Variation",description:"Provocative opening leading to complex positions",moves:[26,25,33],evaluation:0,isMainLine:!1})}addOpening(e,t){const i=t.map(s=>({position:s.pos,score:s.score,frequency:s.freq,winRate:s.win,depth:this.calculateDepth(e),comment:s.comment}));this._entries.set(e,i)}generateKey(e){return Array.from(e.board).map(t=>{switch(t){case d.EMPTY:return"e";case d.BLACK:return"1";case d.WHITE:return"2";default:return"e"}}).join("")}calculateDepth(e){const t=e.split("").filter(i=>i!=="e").length;return Math.max(0,t-4)}getStatistics(){const e=this._entries.size;let t=0,i=0;for(const s of this._entries.values())for(const n of s)t+=n.winRate,i++;return{totalPositions:e,maxDepth:this._maxDepth,averageWinRate:i>0?t/i:0,sequenceCount:this._sequences.length}}validateBook(){const e=[];for(const[t,i]of this._entries.entries()){const s=new Set;for(const n of i)s.has(n.position)&&e.push(`Duplicate position ${n.position} in key ${t}`),s.add(n.position),(n.frequency<0||n.frequency>1)&&e.push(`Invalid frequency for position ${n.position}: ${n.frequency}`),(n.winRate<0||n.winRate>1)&&e.push(`Invalid win rate for position ${n.position}: ${n.winRate}`)}for(const t of this._sequences){t.moves.length===0&&e.push(`Empty sequence: ${t.name}`);for(const i of t.moves)(i<0||i>=64)&&e.push(`Invalid move ${i} in sequence ${t.name}`)}return{isValid:e.length===0,errors:e}}}const pe=new fe;class ve{_config;_transpositionTable=new Map;_nodesSearched=0;_startTime=0;_timeLimit=0;constructor(e={}){this._config={maxEmptySquares:16,useTranspositionTable:!0,useMoveOrdering:!0,maxTimeMs:3e4,enableParity:!0,...e}}async solvePosition(e,t,i){this._startTime=Date.now(),this._timeLimit=i||this._config.maxTimeMs,this._nodesSearched=0;const s=this.countEmptySquares(e.board);if(s>this._config.maxEmptySquares)throw new Error(`Position has ${s} empty squares, exceeds maximum of ${this._config.maxEmptySquares}`);const n=await this.exactSearch(e,t,s,-64,64),o=Date.now()-this._startTime;if(!n.bestMove&&n.bestMove!==0)throw new Error("No valid move found in endgame position");return{bestMove:n.bestMove,exactScore:n.score,movesToEnd:s,isWin:n.score>0,nodesSearched:this._nodesSearched,timeElapsed:o,confidence:1}}canSolve(e){return this.countEmptySquares(e.board)<=this._config.maxEmptySquares}async exactSearch(e,t,i,s,n){if(this._nodesSearched++,Date.now()-this._startTime>=this._timeLimit)throw new Error("Endgame solver timeout");if(this._config.useTranspositionTable){const l=this.lookupTransposition(e,i);if(l)return{score:l.exactScore,bestMove:l.bestMove}}if(e.gameOver||e.validMoves.size===0)return{score:this.calculateFinalScore(e,t)};const o=this.getOrderedMoves(e);let a,c=e.currentPlayer===t?-64:64;for(const l of o){const u=_.makeMove(e,l);if(!u)continue;let h=u;h.validMoves.size===0&&!h.gameOver&&(h=_.makePass(h));const m=await this.exactSearch(h,t,i-1,s,n);if(e.currentPlayer===t?(m.score>c&&(c=m.score,a=l),s=Math.max(s,c)):(m.score<c&&(c=m.score,a=l),n=Math.min(n,c)),n<=s)break}return this._config.useTranspositionTable&&this.storeTransposition(e,i,c,a,s,n),{score:c,bestMove:a}}calculateFinalScore(e,t){let i=0,s=0,n=0;for(let o=0;o<e.board.length;o++){const a=e.board[o];a===t?i++:a!==d.EMPTY?s++:n++}return n>0&&(this._config.enableParity?this.calculateParity(e,t)>0?i+=n:s+=n:e.currentPlayer===t?i+=n:s+=n),i-s}calculateParity(e,t){const i=this.countEmptySquares(e.board),s=e.currentPlayer===t?1:-1;return i%2===1?s:-s}getOrderedMoves(e){const t=Array.from(e.validMoves.keys());if(!this._config.useMoveOrdering)return t;const i=t.map(s=>{let n=0;[0,7,56,63].includes(s)&&(n+=1e3);const o=Math.floor(s/8),a=s%8;(o===0||o===7||a===0||a===7)&&(n+=100);const c=e.validMoves.get(s)?.length||0;return n+=c*10,[9,14,49,54].includes(s)&&(n-=500),{move:s,score:n}});return i.sort((s,n)=>n.score-s.score),i.map(s=>s.move)}countEmptySquares(e){let t=0;for(let i=0;i<e.length;i++)e[i]===d.EMPTY&&t++;return t}generateTranspositionKey(e){return Array.from(e.board).join("")+"_"+e.currentPlayer}lookupTransposition(e,t){const i=this.generateTranspositionKey(e),s=this._transpositionTable.get(i);return s&&s.depth>=t?s:null}storeTransposition(e,t,i,s,n,o){const a=this.generateTranspositionKey(e);let c;i<=n?c="upper":i>=o?c="lower":c="exact",this._transpositionTable.set(a,{exactScore:i,depth:t,bestMove:s,flag:c,timestamp:Date.now()}),this._transpositionTable.size>5e4&&this.cleanupTranspositionTable()}cleanupTranspositionTable(){const e=Date.now()-6e5;for(const[t,i]of this._transpositionTable.entries())i.timestamp<e&&this._transpositionTable.delete(t)}getStatistics(){const e=Date.now()-this._startTime,t=e>0?this._nodesSearched/e*1e3:0;return{transpositionEntries:this._transpositionTable.size,maxEmptySquares:this._config.maxEmptySquares,averageNodesPerSecond:t}}clearCaches(){this._transpositionTable.clear()}setConfig(e){Object.assign(this._config,e)}getConfig(){return{...this._config}}}const ge=new ve;class I extends w{difficulty=v.ADVANCED;name="Advanced AI";description="Master-level AI combining opening book, minimax, and endgame solver";_config;_openingBook;_endgameSolver;_minimaxAI;_phaseStats={opening:{moves:0,totalTime:0},midgame:{moves:0,totalTime:0},endgame:{moves:0,totalTime:0}};constructor(e={}){super(),this._config={useOpeningBook:!0,openingBookDepth:12,minimaxDepth:8,minimaxTimeLimit:5e3,useIterativeDeepening:!0,useEndgameSolver:!0,endgameThreshold:16,endgameTimeLimit:3e4,adaptiveTimeManagement:!0,thinkingTimeBase:1e3,thinkingTimeMax:1e4,useMonteCarlo:!1,monteCarloSamples:1e3,useAspirationWindows:!0,...e},this._openingBook=pe,this._endgameSolver=ge;const t={maxDepth:this._config.minimaxDepth,maxTime:this._config.minimaxTimeLimit,useIterativeDeepening:this._config.useIterativeDeepening,useTranspositionTable:!0,useMoveOrdering:!0,aspirationWindow:this._config.useAspirationWindows?50:void 0};this._minimaxAI=new b(t)}async selectMoveImpl(e,t,i){const s=Date.now(),n=this.detectGamePhase(e),o=this.calculateAdaptiveTimeLimit(e,i,n);let a;try{switch(n){case"opening":a=await this.handleOpening(e,t,o);break;case"midgame":a=await this.handleMidgame(e,t,o);break;case"endgame":a=await this.handleEndgame(e,t,o);break;default:a=await this.handleMidgame(e,t,o)}const c=Date.now()-s;return this._phaseStats[n].moves++,this._phaseStats[n].totalTime+=c,{...a,thinkingTime:c}}catch{return this._minimaxAI.selectMove(e,t,o)}}async handleOpening(e,t,i){if(this._config.useOpeningBook&&this._openingBook.hasOpeningMove(e)){const s=this._openingBook.getOpeningMove(e);if(s!==null){const n=200+Math.random()*300;return await new Promise(o=>setTimeout(o,n)),{position:s,confidence:.9,evaluation:0,thinkingTime:n,depth:this._openingBook.getOpeningDepth(e),nodesEvaluated:1}}}return this._minimaxAI.selectMove(e,t,i)}async handleMidgame(e,t,i){return this._minimaxAI.selectMove(e,t,i)}async handleEndgame(e,t,i){if(!this._config.useEndgameSolver)return this._minimaxAI.selectMove(e,t,i);const s=_.fromGameState(e);if(this._endgameSolver.canSolve(s))try{const a=await this._endgameSolver.solvePosition(s,t,Math.min(i,this._config.endgameTimeLimit));return{position:a.bestMove,confidence:a.confidence,evaluation:a.exactScore,thinkingTime:a.timeElapsed,depth:a.movesToEnd,nodesEvaluated:a.nodesSearched}}catch{}const n={maxDepth:this._config.minimaxDepth+2,maxTime:i,useIterativeDeepening:!0};return new b(n).selectMove(e,t,i)}detectGamePhase(e){const t=e.scores.black+e.scores.white,i=64-t;return t<=12?"opening":i<=this._config.endgameThreshold?"endgame":"midgame"}calculateAdaptiveTimeLimit(e,t,i){if(!this._config.adaptiveTimeManagement)return t;const s=e.validMoves.size,n=this.assessPositionComplexity(e);let o=1;switch(i){case"opening":o=.3;break;case"midgame":o=1;break;case"endgame":o=2;break}o*=1+n*.5,s>10?o*=1.3:s<3&&(o*=.7);const a=Math.min(this._config.thinkingTimeMax,Math.max(this._config.thinkingTimeBase*o,t*.5));return Math.min(a,t)}assessPositionComplexity(e){let t=0;t+=Math.min(e.validMoves.size/15,1);const i=Math.abs(e.scores.black-e.scores.white);t+=Math.min(i/20,.5);const n=[0,7,56,63].filter(o=>e.board[o]===d.EMPTY);return t+=n.length*.1,Math.min(t,1)}getConfig(){return{...this._config}}setConfig(e){Object.assign(this._config,e);const t={maxDepth:this._config.minimaxDepth,maxTime:this._config.minimaxTimeLimit,useIterativeDeepening:this._config.useIterativeDeepening,aspirationWindow:this._config.useAspirationWindows?50:void 0};this._minimaxAI.setConfig(t)}getPerformanceStats(){const e={moves:this._phaseStats.opening.moves,avgTime:this._phaseStats.opening.moves>0?this._phaseStats.opening.totalTime/this._phaseStats.opening.moves:0},t={moves:this._phaseStats.midgame.moves,avgTime:this._phaseStats.midgame.moves>0?this._phaseStats.midgame.totalTime/this._phaseStats.midgame.moves:0},i={moves:this._phaseStats.endgame.moves,avgTime:this._phaseStats.endgame.moves>0?this._phaseStats.endgame.totalTime/this._phaseStats.endgame.moves:0},s=e.moves+t.moves+i.moves,n=this._phaseStats.opening.totalTime+this._phaseStats.midgame.totalTime+this._phaseStats.endgame.totalTime;return{opening:e,midgame:t,endgame:i,totalMoves:s,overallAvgTime:s>0?n/s:0}}resetStats(){this._phaseStats={opening:{moves:0,totalTime:0},midgame:{moves:0,totalTime:0},endgame:{moves:0,totalTime:0}}}clearCaches(){this._minimaxAI.clearCaches(),this._endgameSolver.clearCaches()}}const P={tournament(){return new I({useOpeningBook:!0,openingBookDepth:12,minimaxDepth:8,useEndgameSolver:!0,endgameThreshold:16,adaptiveTimeManagement:!0,thinkingTimeBase:2e3,thinkingTimeMax:15e3})},master(){return new I({useOpeningBook:!0,openingBookDepth:16,minimaxDepth:10,useEndgameSolver:!0,endgameThreshold:20,adaptiveTimeManagement:!0,thinkingTimeBase:3e3,thinkingTimeMax:3e4,useAspirationWindows:!0})},blitz(){return new I({useOpeningBook:!0,openingBookDepth:8,minimaxDepth:6,useEndgameSolver:!0,endgameThreshold:12,adaptiveTimeManagement:!1,thinkingTimeBase:500,thinkingTimeMax:2e3})},custom(r){return new I(r)}};function Me(r,e){switch(r){case v.RANDOM:return X.smart();case v.GREEDY:return V.adaptive();case v.MINIMAX_EASY:return R.basic();case v.MINIMAX:return R.intermediate();case v.MINIMAX_HARD:return R.advanced();case v.ADVANCED:return P.tournament();case v.MASTER:return P.master();case v.BLITZ:return P.blitz();case v.CUSTOM:return e?P.custom(e):P.tournament();default:return V.standard()}}self.addEventListener("message",async r=>{const{type:e,payload:t}=r.data;if(e==="CALCULATE_MOVE"){const{id:i,gameState:s,player:n,difficulty:o,timeLimit:a,customConfig:c}=t;try{const l=Me(o,c),u=Date.now(),h=await l.selectMove(s,n,a),m=Date.now()-u,f={type:"MOVE_RESULT",payload:{id:i,result:{...h,thinkingTime:m}}};self.postMessage(f)}catch(l){const u={type:"ERROR",payload:{id:i,error:l instanceof Error?l.message:"Unknown AI error"}};self.postMessage(u)}}})})();
//# sourceMappingURL=ai-worker-DsUjjSSv.js.map
