{"version":3,"file":"ai-worker-CWqBa3j1.js","sources":["../src/types/game-types.ts","../src/core/ai/ai-strategy-base.ts","../src/core/ai/strategies/random-ai.ts","../src/core/utils/board-utils.ts","../src/core/utils/move-validator.ts","../src/core/utils/move-evaluator.ts","../src/core/ai/strategies/greedy-ai.ts","../src/core/ai/strategies/evaluation.ts","../src/core/ai/game-simulator.ts","../src/core/ai/strategies/minimax-ai.ts","../src/core/ai/strategies/opening-book.ts","../src/core/ai/strategies/endgame-solver.ts","../src/core/ai/strategies/advanced-ai.ts","../src/workers/ai-worker.ts"],"sourcesContent":["/**\r\n * Core Game Type Definitions\r\n *\r\n * Fundamental types used throughout the Super Reversi game.\r\n * These types define the core game state, player information,\r\n * and basic game mechanics.\r\n */\r\n\r\n// Basic game constants\r\nexport const BOARD_SIZE = 8;\r\nexport const TOTAL_SQUARES = 64;\r\nexport const DIRECTIONS = [-9, -8, -7, -1, 1, 7, 8, 9] as const;\r\n\r\n// Player and piece representation\r\nexport enum PlayerColor {\r\n  EMPTY = 0,\r\n  BLACK = 1,\r\n  WHITE = 2,\r\n}\r\n\r\nexport enum PlayerType {\r\n  HUMAN = 'human',\r\n  AI = 'ai',\r\n}\r\n\r\nexport enum GameStatus {\r\n  WAITING = 'waiting',\r\n  IN_PROGRESS = 'in_progress',\r\n  PAUSED = 'paused',\r\n  GAME_OVER = 'game_over',\r\n}\r\n\r\n// Move quality grades\r\nexport enum Grade {\r\n  C = 'C',    // Basic moves (0-9 points)\r\n  B = 'B',    // Good moves (10-17 points)\r\n  A = 'A',    // Great moves (18-29 points)\r\n  S = 'S',    // Exceptional moves (30-44 points)\r\n  SS = 'SS',  // Master moves (45-59 points)\r\n  SSS = 'SSS' // Legendary moves (60+ points)\r\n}\r\n\r\n// AI difficulty levels\r\nexport enum AIDifficulty {\r\n  RANDOM = 'v0',      // Random valid moves\r\n  GREEDY = 'v1',      // Immediate best score\r\n  MINIMAX = 'v2',     // Look-ahead with alpha-beta pruning\r\n  ADVANCED = 'v3',    // Opening book + minimax + endgame solver\r\n  MINIMAX_EASY = 'v2a',    // Minimax depth 2-4\r\n  MINIMAX_HARD = 'v2b',    // Minimax depth 4-6 + features\r\n  MASTER = 'v3_master',    // Maximum strength advanced AI\r\n  BLITZ = 'v3_blitz',     // Fast advanced AI for quick games\r\n  CUSTOM = 'custom',       // User-configurable AI\r\n}\r\n\r\n// Board position (0-63)\r\nexport type BoardPosition = number;\r\n\r\n// Position value constants for scoring\r\nexport const POSITION_VALUES = {\r\n  CORNER: 25,\r\n  EDGE: 6,\r\n  X_SQUARE: -10,  // Diagonal from corner\r\n  C_SQUARE: -6,   // Adjacent to corner\r\n  NORMAL: 0,\r\n} as const;\r\n\r\n// Grade thresholds\r\nexport const GRADE_THRESHOLDS = {\r\n  B: 10,\r\n  A: 18,\r\n  S: 30,\r\n  SS: 45,\r\n  SSS: 60,\r\n} as const;\r\n\r\n// Animation and timing constants\r\nexport const ANIMATION_TIMINGS = {\r\n  PREPARATION: 200,  // ms - 0.2 second prep phase\r\n  FLIP: 400,         // ms - 0.4 second flip animation\r\n  TOTAL: 600,        // ms - Total animation duration\r\n  EFFECTS_MIN: 350,  // ms - Minimum effect duration\r\n  EFFECTS_MAX: 900,  // ms - Maximum effect duration\r\n} as const;\r\n\r\n// Performance limits\r\nexport const PARTICLE_LIMITS = {\r\n  MIN: 1200,\r\n  MAX: 1800,\r\n  LOW_PERFORMANCE: 600,\r\n} as const;\r\n\r\nexport const PERFORMANCE_TARGETS = {\r\n  TARGET_FPS: 60,\r\n  MAX_FRAME_TIME: 16, // ms for 60fps\r\n  AI_RESPONSE_TIME: {\r\n    v0: 100,        // ms - Random should be instant\r\n    v1: 1000,       // ms - Greedy evaluation\r\n    v2: 3000,       // ms - Minimax search\r\n    v3: 5000,       // ms - Advanced with endgame\r\n    v2a: 2000,      // ms - Easy minimax\r\n    v2b: 4000,      // ms - Hard minimax\r\n    v3_master: 10000, // ms - Master level\r\n    v3_blitz: 1500,   // ms - Blitz games\r\n    custom: 5000,     // ms - Default for custom\r\n  },\r\n} as const;\r\n\r\n// Player information\r\nexport interface Player {\r\n  type: PlayerType;\r\n  color: PlayerColor;\r\n  name: string;\r\n  stats: PlayerStats;\r\n}\r\n\r\nexport interface PlayerStats {\r\n  movesPlayed: number;\r\n  averageScore: number;\r\n  gradeDistribution: Record<Grade, number>;\r\n  totalThinkingTime: number;\r\n  gamesWon: number;\r\n  gamesLost: number;\r\n  gamesTied: number;\r\n}\r\n\r\n// Game configuration\r\nexport interface GameOptions {\r\n  playerBlack: PlayerType;\r\n  playerWhite: PlayerType;\r\n  aiDifficulty?: AIDifficulty;\r\n  startingPlayer?: PlayerColor;\r\n  boardSize?: number; // Always 8 for standard Reversi\r\n}\r\n\r\n// Board utilities\r\nexport interface BoardPosition2D {\r\n  row: number;\r\n  col: number;\r\n}\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n// Validation helpers\r\nexport const isValidPosition = (position: BoardPosition): boolean => {\r\n  return position >= 0 && position < TOTAL_SQUARES;\r\n};\r\n\r\nexport const isValidColor = (color: PlayerColor): boolean => {\r\n  return Object.values(PlayerColor).includes(color);\r\n};\r\n\r\nexport const positionToCoords = (position: BoardPosition): BoardPosition2D => {\r\n  return {\r\n    row: Math.floor(position / BOARD_SIZE),\r\n    col: position % BOARD_SIZE,\r\n  };\r\n};\r\n\r\nexport const coordsToPosition = (row: number, col: number): BoardPosition => {\r\n  return row * BOARD_SIZE + col;\r\n};\r\n\r\nexport const positionToPoint = (position: BoardPosition, cellSize: number = 50): Point => {\r\n  const coords = positionToCoords(position);\r\n  return {\r\n    x: coords.col * cellSize + cellSize / 2,\r\n    y: coords.row * cellSize + cellSize / 2,\r\n  };\r\n};\r\n\r\n// Position analysis helpers\r\nexport const isCorner = (position: BoardPosition): boolean => {\r\n  return [0, 7, 56, 63].includes(position);\r\n};\r\n\r\nexport const isEdge = (position: BoardPosition): boolean => {\r\n  const coords = positionToCoords(position);\r\n  return coords.row === 0 || coords.row === 7 || coords.col === 0 || coords.col === 7;\r\n};\r\n\r\nexport const isXSquare = (position: BoardPosition): boolean => {\r\n  // Squares diagonally adjacent to corners\r\n  return [9, 14, 49, 54].includes(position);\r\n};\r\n\r\nexport const isCSquare = (position: BoardPosition): boolean => {\r\n  // Squares adjacent to corners (excluding X-squares)\r\n  return [1, 6, 8, 15, 48, 55, 57, 62].includes(position);\r\n};\r\n\r\nexport const getPositionValue = (position: BoardPosition): number => {\r\n  if (isCorner(position)) {return POSITION_VALUES.CORNER;}\r\n  if (isXSquare(position)) {return POSITION_VALUES.X_SQUARE;}\r\n  if (isCSquare(position)) {return POSITION_VALUES.C_SQUARE;}\r\n  if (isEdge(position)) {return POSITION_VALUES.EDGE;}\r\n  return POSITION_VALUES.NORMAL;\r\n};\r\n\r\n// Direction helpers for move validation\r\nexport const getDirectionOffset = (direction: number): BoardPosition2D => {\r\n  return {\r\n    row: Math.floor(direction / BOARD_SIZE) - 1,\r\n    col: (direction % BOARD_SIZE) - 1,\r\n  };\r\n};\r\n\r\nexport const isValidDirection = (from: BoardPosition, direction: number): boolean => {\r\n  const fromCoords = positionToCoords(from);\r\n  const dirOffset = getDirectionOffset(direction + 8); // Adjust for array indexing\r\n  const newRow = fromCoords.row + dirOffset.row;\r\n  const newCol = fromCoords.col + dirOffset.col;\r\n\r\n  return newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE;\r\n};\r\n\r\n// Type guards\r\nexport const isPlayerColor = (value: unknown): value is PlayerColor => {\r\n  return typeof value === 'number' && Object.values(PlayerColor).includes(value as PlayerColor);\r\n};\r\n\r\nexport const isGrade = (value: unknown): value is Grade => {\r\n  return typeof value === 'string' && Object.values(Grade).includes(value as Grade);\r\n};\r\n\r\nexport const isAIDifficulty = (value: unknown): value is AIDifficulty => {\r\n  return typeof value === 'string' && Object.values(AIDifficulty).includes(value as AIDifficulty);\r\n};\r\n\r\nexport const isGameStatus = (value: unknown): value is GameStatus => {\r\n  return typeof value === 'string' && Object.values(GameStatus).includes(value as GameStatus);\r\n};\r\n\r\n// Error types for game operations\r\nexport class InvalidMoveError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly position: BoardPosition,\r\n    public readonly reason: string,\r\n  ) {\r\n    super(message);\r\n    this.name = 'InvalidMoveError';\r\n  }\r\n}\r\n\r\nexport class GameStateError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly gameStatus: GameStatus,\r\n  ) {\r\n    super(message);\r\n    this.name = 'GameStateError';\r\n  }\r\n}\r\n\r\nexport class AIError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly difficulty: AIDifficulty,\r\n    public readonly cause?: Error,\r\n  ) {\r\n    super(message);\r\n    this.name = 'AIError';\r\n  }\r\n}","/**\r\n * AI Strategy Base Classes\r\n *\r\n * Abstract base classes and interfaces for implementing different AI strategies.\r\n * Provides common structure for v0 (Random), v1 (Greedy), v2 (Minimax), v3 (Advanced).\r\n */\r\n\r\nimport {\r\n  BoardPosition,\r\n  PlayerColor,\r\n  AIDifficulty,\r\n  PERFORMANCE_TARGETS,\r\n} from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\n// import type { Move } from '@/core/models/Move';\r\n\r\n/**\r\n * AI move selection result\r\n */\r\nexport interface AIMoveResult {\r\n  readonly position: BoardPosition;\r\n  readonly confidence: number; // 0-1, how confident the AI is in this move\r\n  readonly evaluation: number; // Numeric evaluation score\r\n  readonly thinkingTime: number; // Time spent calculating (ms)\r\n  readonly depth?: number; // Search depth used (for minimax variants)\r\n  readonly nodesEvaluated?: number; // Nodes explored (for analytics)\r\n}\r\n\r\n/**\r\n * AI thinking process metadata\r\n */\r\nexport interface AIThinkingProcess {\r\n  readonly startTime: number;\r\n  readonly targetTime: number; // Maximum thinking time allowed\r\n  readonly depth: number; // Current search depth\r\n  readonly nodesEvaluated: number;\r\n  readonly bestMove?: BoardPosition;\r\n  readonly bestScore?: number;\r\n}\r\n\r\n/**\r\n * AI performance metrics\r\n */\r\nexport interface AIPerformanceMetrics {\r\n  readonly averageThinkingTime: number;\r\n  readonly movesPlayed: number;\r\n  readonly totalNodesEvaluated: number;\r\n  readonly averageDepth: number;\r\n  readonly timeoutCount: number; // How many times AI hit time limit\r\n  readonly accuracy: number; // Estimated move quality (0-1)\r\n}\r\n\r\n/**\r\n * Base interface for all AI strategies\r\n */\r\nexport interface IAIStrategy {\r\n  readonly difficulty: AIDifficulty;\r\n  readonly name: string;\r\n  readonly description: string;\r\n\r\n  /**\r\n   * Select the best move for the given game state\r\n   */\r\n  selectMove(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit?: number\r\n  ): Promise<AIMoveResult>;\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics(): AIPerformanceMetrics;\r\n\r\n  /**\r\n   * Reset performance metrics\r\n   */\r\n  resetMetrics(): void;\r\n\r\n  /**\r\n   * Check if AI is currently thinking\r\n   */\r\n  isThinking(): boolean;\r\n\r\n  /**\r\n   * Stop current thinking process (for timeout/cancellation)\r\n   */\r\n  stopThinking(): void;\r\n}\r\n\r\n/**\r\n * Abstract base class for AI strategies\r\n */\r\nexport abstract class AIStrategyBase implements IAIStrategy {\r\n  public abstract readonly difficulty: AIDifficulty;\r\n  public abstract readonly name: string;\r\n  public abstract readonly description: string;\r\n\r\n  protected _isThinking = false;\r\n  protected _shouldStop = false;\r\n  protected _metrics: AIPerformanceMetrics = {\r\n    averageThinkingTime: 0,\r\n    movesPlayed: 0,\r\n    totalNodesEvaluated: 0,\r\n    averageDepth: 0,\r\n    timeoutCount: 0,\r\n    accuracy: 0,\r\n  };\r\n\r\n  protected _thinkingHistory: number[] = [];\r\n  protected _depthHistory: number[] = [];\r\n  protected _nodeHistory: number[] = [];\r\n\r\n  /**\r\n   * Main move selection interface\r\n   */\r\n  async selectMove(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit?: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n    const targetTime = timeLimit || this.getDefaultTimeLimit();\r\n\r\n    this._isThinking = true;\r\n    this._shouldStop = false;\r\n\r\n    try {\r\n      const result = await this.selectMoveImpl(gameState, player, targetTime);\r\n      const actualThinkingTime = Date.now() - startTime;\r\n\r\n      // Update metrics\r\n      this.updateMetrics(result, actualThinkingTime, targetTime);\r\n\r\n      return {\r\n        ...result,\r\n        thinkingTime: actualThinkingTime,\r\n      };\r\n    } finally {\r\n      this._isThinking = false;\r\n      this._shouldStop = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Abstract method that subclasses must implement\r\n   */\r\n  protected abstract selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number\r\n  ): Promise<AIMoveResult>;\r\n\r\n  /**\r\n   * Get default time limit for this difficulty level\r\n   */\r\n  protected getDefaultTimeLimit(): number {\r\n    return PERFORMANCE_TARGETS.AI_RESPONSE_TIME[this.difficulty] || 1000;\r\n  }\r\n\r\n  /**\r\n   * Check if we should stop thinking (timeout or cancellation)\r\n   */\r\n  protected shouldStop(startTime: number, timeLimit: number): boolean {\r\n    return this._shouldStop || (Date.now() - startTime) >= timeLimit;\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics after a move\r\n   */\r\n  protected updateMetrics(\r\n    result: AIMoveResult,\r\n    actualTime: number,\r\n    timeLimit: number,\r\n  ): void {\r\n    this._thinkingHistory.push(actualTime);\r\n    if (result.depth !== undefined) {\r\n      this._depthHistory.push(result.depth);\r\n    }\r\n    if (result.nodesEvaluated !== undefined) {\r\n      this._nodeHistory.push(result.nodesEvaluated);\r\n    }\r\n\r\n    const movesPlayed = this._thinkingHistory.length;\r\n    const totalThinkingTime = this._thinkingHistory.reduce((sum, time) => sum + time, 0);\r\n    const totalNodes = this._nodeHistory.reduce((sum, nodes) => sum + nodes, 0);\r\n    const totalDepth = this._depthHistory.reduce((sum, depth) => sum + depth, 0);\r\n\r\n    this._metrics = {\r\n      averageThinkingTime: totalThinkingTime / movesPlayed,\r\n      movesPlayed,\r\n      totalNodesEvaluated: totalNodes,\r\n      averageDepth: this._depthHistory.length > 0 ? totalDepth / this._depthHistory.length : 0,\r\n      timeoutCount: this._metrics.timeoutCount + (actualTime >= timeLimit ? 1 : 0),\r\n      accuracy: this.estimateAccuracy(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Estimate move accuracy based on thinking time and difficulty\r\n   */\r\n  protected estimateAccuracy(): number {\r\n    if (this._metrics.movesPlayed === 0) {return 0;}\r\n\r\n    const targetTime = this.getDefaultTimeLimit();\r\n    const actualTime = this._metrics.averageThinkingTime;\r\n\r\n    // Simple heuristic: accuracy increases with thinking time up to target\r\n    const timeRatio = Math.min(actualTime / targetTime, 1.0);\r\n    const baseAccuracy = this.getBaseAccuracy();\r\n\r\n    return Math.min(baseAccuracy + (timeRatio * 0.3), 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get base accuracy for this difficulty level\r\n   */\r\n  protected getBaseAccuracy(): number {\r\n    switch (this.difficulty) {\r\n      case AIDifficulty.RANDOM: return 0.1;  // Very low accuracy\r\n      case AIDifficulty.GREEDY: return 0.6;  // Decent accuracy\r\n      case AIDifficulty.MINIMAX: return 0.8; // High accuracy\r\n      case AIDifficulty.ADVANCED: return 0.9; // Very high accuracy\r\n      default: return 0.5;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics(): AIPerformanceMetrics {\r\n    return { ...this._metrics };\r\n  }\r\n\r\n  /**\r\n   * Reset performance metrics\r\n   */\r\n  resetMetrics(): void {\r\n    this._metrics = {\r\n      averageThinkingTime: 0,\r\n      movesPlayed: 0,\r\n      totalNodesEvaluated: 0,\r\n      averageDepth: 0,\r\n      timeoutCount: 0,\r\n      accuracy: 0,\r\n    };\r\n    this._thinkingHistory = [];\r\n    this._depthHistory = [];\r\n    this._nodeHistory = [];\r\n  }\r\n\r\n  /**\r\n   * Check if AI is currently thinking\r\n   */\r\n  isThinking(): boolean {\r\n    return this._isThinking;\r\n  }\r\n\r\n  /**\r\n   * Stop current thinking process\r\n   */\r\n  stopThinking(): void {\r\n    this._shouldStop = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility functions for AI implementations\r\n */\r\nexport class AIUtils {\r\n  /**\r\n   * Add random jitter to move selection to avoid predictable play\r\n   */\r\n  static addJitter(baseScore: number, jitterAmount = 0.1): number {\r\n    const jitter = (Math.random() - 0.5) * 2 * jitterAmount;\r\n    return baseScore + jitter;\r\n  }\r\n\r\n  /**\r\n   * Select move from candidates with weighted randomization\r\n   */\r\n  static selectWeightedRandom<T extends { score: number }>(\r\n    candidates: T[],\r\n    temperature = 1.0,\r\n  ): T {\r\n    if (candidates.length === 0) {\r\n      throw new Error('No candidates to select from');\r\n    }\r\n\r\n    if (candidates.length === 1) {\r\n      return candidates[0] as T;\r\n    }\r\n\r\n    // Apply temperature scaling to scores\r\n    const scaledCandidates = candidates.map(candidate => ({\r\n      ...candidate,\r\n      weight: Math.exp(candidate.score / temperature),\r\n    }));\r\n\r\n    const totalWeight = scaledCandidates.reduce((sum, candidate) => sum + candidate.weight, 0);\r\n    const randomValue = Math.random() * totalWeight;\r\n\r\n    let cumulativeWeight = 0;\r\n    for (const candidate of scaledCandidates) {\r\n      cumulativeWeight += candidate.weight;\r\n      if (randomValue <= cumulativeWeight) {\r\n        return candidate as T;\r\n      }\r\n    }\r\n\r\n    // Fallback to last candidate (this shouldn't happen but ensures type safety)\r\n    return scaledCandidates[scaledCandidates.length - 1] as T;\r\n  }\r\n\r\n  /**\r\n   * Evaluate position stability for AI decision making\r\n   */\r\n  static evaluatePositionStability(\r\n    gameState: GameState,\r\n    position: BoardPosition,\r\n    player: PlayerColor,\r\n  ): number {\r\n    // Simple stability heuristic based on position type and surrounding pieces\r\n    let stability = 0;\r\n\r\n    // Corner positions are extremely stable\r\n    if ([0, 7, 56, 63].includes(position)) {\r\n      stability += 10;\r\n    }\r\n\r\n    // Edge positions have moderate stability\r\n    const row = Math.floor(position / 8);\r\n    const col = position % 8;\r\n    if (row === 0 || row === 7 || col === 0 || col === 7) {\r\n      stability += 3;\r\n    }\r\n\r\n    // Check for friendly neighbors (increases stability)\r\n    const neighbors = this.getNeighbors(position);\r\n    const friendlyNeighbors = neighbors.filter(pos =>\r\n      gameState.board[pos] === player,\r\n    ).length;\r\n\r\n    stability += friendlyNeighbors * 0.5;\r\n\r\n    return stability;\r\n  }\r\n\r\n  /**\r\n   * Get neighboring positions\r\n   */\r\n  private static getNeighbors(position: BoardPosition): BoardPosition[] {\r\n    const neighbors: BoardPosition[] = [];\r\n    const row = Math.floor(position / 8);\r\n    const col = position % 8;\r\n\r\n    for (let dr = -1; dr <= 1; dr++) {\r\n      for (let dc = -1; dc <= 1; dc++) {\r\n        if (dr === 0 && dc === 0) {continue;}\r\n\r\n        const newRow = row + dr;\r\n        const newCol = col + dc;\r\n\r\n        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\r\n          neighbors.push(newRow * 8 + newCol);\r\n        }\r\n      }\r\n    }\r\n\r\n    return neighbors;\r\n  }\r\n\r\n  /**\r\n   * Calculate endgame phase (0 = early game, 1 = endgame)\r\n   */\r\n  static getGamePhase(gameState: GameState): number {\r\n    const totalPieces = gameState.scores.black + gameState.scores.white;\r\n    const maxPieces = 64;\r\n    return totalPieces / maxPieces;\r\n  }\r\n\r\n  /**\r\n   * Simple mobility calculation\r\n   */\r\n  static calculateMobility(gameState: GameState, _player: PlayerColor): number {\r\n    return gameState.validMoves.size;\r\n  }\r\n\r\n  /**\r\n   * Check if position is in dangerous area (X-squares, C-squares)\r\n   */\r\n  static isDangerousPosition(position: BoardPosition): boolean {\r\n    // X-squares (diagonal from corners) and C-squares (adjacent to corners)\r\n    const dangerousPositions = [\r\n      1, 6, 8, 9, 14, 15, // Top area\r\n      48, 49, 54, 55, 57, 62, // Bottom area\r\n    ];\r\n    return dangerousPositions.includes(position);\r\n  }\r\n}","/**\r\n * Random AI Strategy (v0)\r\n *\r\n * Simplest AI implementation that selects random valid moves.\r\n * Used for testing and as a baseline for other AI strategies.\r\n * Should respond almost instantly (<100ms).\r\n */\r\n\r\nimport { AIDifficulty, PlayerColor, BoardPosition } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\nimport { AIStrategyBase, type AIMoveResult, AIUtils } from '../ai-strategy-base';\r\n\r\n/**\r\n * Random AI implementation\r\n */\r\nexport class RandomAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.RANDOM;\r\n  public readonly name = 'Random AI';\r\n  public readonly description = 'Selects random valid moves with no strategy';\r\n\r\n  /**\r\n   * Select a random valid move\r\n   */\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    _player: PlayerColor,\r\n    _timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n\r\n    // Get all valid moves\r\n    const validMoves = Array.from(gameState.validMoves.keys());\r\n\r\n    if (validMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    // Add tiny random delay to simulate thinking (but stay under 100ms)\r\n    const thinkingDelay = Math.random() * 50; // 0-50ms\r\n    await new Promise(resolve => setTimeout(resolve, thinkingDelay));\r\n\r\n    // Select random move\r\n    const randomIndex = Math.floor(Math.random() * validMoves.length);\r\n    const selectedPosition = validMoves[randomIndex];\r\n\r\n    // Calculate basic evaluation score (just for metrics)\r\n    const evaluation = this.evaluateMove(gameState, selectedPosition!, _player);\r\n\r\n    return {\r\n      position: selectedPosition!,\r\n      confidence: 0.1, // Very low confidence since it's random\r\n      evaluation,\r\n      thinkingTime: Date.now() - startTime,\r\n      depth: 0, // No search depth\r\n      nodesEvaluated: validMoves.length, // Only evaluated immediate moves\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Simple move evaluation for metrics (not used for selection)\r\n   */\r\n  private evaluateMove(\r\n    gameState: GameState,\r\n    position: BoardPosition,\r\n    _player: PlayerColor,\r\n  ): number {\r\n    // Basic evaluation based on position value and flips\r\n    const flippedPositions = gameState.validMoves.get(position) || [];\r\n    let score = 0;\r\n\r\n    // Position value\r\n    if ([0, 7, 56, 63].includes(position)) {\r\n      score += 25; // Corner\r\n    } else if (this.isEdgePosition(position)) {\r\n      score += 6; // Edge\r\n    } else if ([9, 14, 49, 54].includes(position)) {\r\n      score -= 10; // X-square (dangerous)\r\n    }\r\n\r\n    // Flipped pieces\r\n    score += flippedPositions.length;\r\n\r\n    // Add small random component for variety\r\n    score += AIUtils.addJitter(0, 0.5);\r\n\r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Check if position is on the edge\r\n   */\r\n  private isEdgePosition(position: BoardPosition): boolean {\r\n    const row = Math.floor(position / 8);\r\n    const col = position % 8;\r\n    return row === 0 || row === 7 || col === 0 || col === 7;\r\n  }\r\n}\r\n\r\n/**\r\n * Slightly improved random AI that avoids obviously bad moves\r\n */\r\nexport class SmartRandomAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.RANDOM;\r\n  public readonly name = 'Smart Random AI';\r\n  public readonly description = 'Random moves but avoids obviously terrible positions';\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    _player: PlayerColor,\r\n    _timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n\r\n    const validMoves = Array.from(gameState.validMoves.keys());\r\n\r\n    if (validMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    // Categorize moves\r\n    const cornerMoves = validMoves.filter(pos => [0, 7, 56, 63].includes(pos));\r\n    const safeEdgeMoves = validMoves.filter(pos =>\r\n      this.isEdgePosition(pos) && ![0, 7, 56, 63].includes(pos) && !this.isXSquare(pos),\r\n    );\r\n    const xSquareMoves = validMoves.filter(pos => [9, 14, 49, 54].includes(pos));\r\n    const normalMoves = validMoves.filter(pos =>\r\n      !cornerMoves.includes(pos) &&\r\n      !safeEdgeMoves.includes(pos) &&\r\n      !xSquareMoves.includes(pos),\r\n    );\r\n\r\n    let candidateMoves: BoardPosition[];\r\n    let moveType: string;\r\n\r\n    // Selection priority: Corners > Safe edges > Normal > X-squares (last resort)\r\n    if (cornerMoves.length > 0) {\r\n      candidateMoves = cornerMoves;\r\n      moveType = 'corner';\r\n    } else if (safeEdgeMoves.length > 0) {\r\n      candidateMoves = safeEdgeMoves;\r\n      moveType = 'safe_edge';\r\n    } else if (normalMoves.length > 0) {\r\n      candidateMoves = normalMoves;\r\n      moveType = 'normal';\r\n    } else {\r\n      candidateMoves = xSquareMoves;\r\n      moveType = 'x_square';\r\n    }\r\n\r\n    // Add thinking delay\r\n    const thinkingDelay = Math.random() * 75; // 0-75ms\r\n    await new Promise(resolve => setTimeout(resolve, thinkingDelay));\r\n\r\n    // Select random from candidates\r\n    const randomIndex = Math.floor(Math.random() * candidateMoves.length);\r\n    const selectedPosition = candidateMoves[randomIndex];\r\n\r\n    // Evaluate selected move\r\n    const evaluation = this.evaluateMove(gameState, selectedPosition!, _player);\r\n\r\n    // Higher confidence for better move types\r\n    const confidence = this.getConfidenceForMoveType(moveType);\r\n\r\n    return {\r\n      position: selectedPosition!,\r\n      confidence,\r\n      evaluation,\r\n      thinkingTime: Date.now() - startTime,\r\n      depth: 1, // One level of categorization\r\n      nodesEvaluated: validMoves.length,\r\n    };\r\n  }\r\n\r\n  private evaluateMove(\r\n    gameState: GameState,\r\n    position: BoardPosition,\r\n    _player: PlayerColor,\r\n  ): number {\r\n    const flippedPositions = gameState.validMoves.get(position) || [];\r\n    let score = 0;\r\n\r\n    // Position value\r\n    if ([0, 7, 56, 63].includes(position)) {\r\n      score += 25;\r\n    } else if (this.isEdgePosition(position)) {\r\n      score += 6;\r\n    } else if ([9, 14, 49, 54].includes(position)) {\r\n      score -= 10;\r\n    }\r\n\r\n    // Flipped pieces\r\n    score += flippedPositions.length;\r\n\r\n    return score;\r\n  }\r\n\r\n  private isEdgePosition(position: BoardPosition): boolean {\r\n    const row = Math.floor(position / 8);\r\n    const col = position % 8;\r\n    return row === 0 || row === 7 || col === 0 || col === 7;\r\n  }\r\n\r\n  private isXSquare(position: BoardPosition): boolean {\r\n    return [9, 14, 49, 54].includes(position);\r\n  }\r\n\r\n  private getConfidenceForMoveType(moveType: string): number {\r\n    switch (moveType) {\r\n      case 'corner': return 0.8;\r\n      case 'safe_edge': return 0.6;\r\n      case 'normal': return 0.3;\r\n      case 'x_square': return 0.1;\r\n      default: return 0.2;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create random AI variants\r\n */\r\nexport const createRandomAI = {\r\n  /**\r\n   * Pure random selection\r\n   */\r\n  pure(): RandomAI {\r\n    return new RandomAI();\r\n  },\r\n\r\n  /**\r\n   * Smart random (avoids obviously bad moves)\r\n   */\r\n  smart(): SmartRandomAI {\r\n    return new SmartRandomAI();\r\n  },\r\n};","/**\r\n * Board Utilities\r\n *\r\n * Core utilities for board position conversion, direction vectors,\r\n * and spatial relationships in the 8x8 Reversi game.\r\n */\r\n\r\nimport {\r\n  BOARD_SIZE,\r\n  TOTAL_SQUARES,\r\n  DIRECTIONS,\r\n  BoardPosition,\r\n  BoardPosition2D,\r\n  Point,\r\n  PlayerColor,\r\n  isValidPosition,\r\n} from '@/types/game-types';\r\n\r\n/**\r\n * Convert linear board position to 2D coordinates\r\n */\r\nexport const positionToCoords = (position: BoardPosition): BoardPosition2D => {\r\n  if (!isValidPosition(position)) {\r\n    throw new Error(`Invalid position: ${position}`);\r\n  }\r\n  return {\r\n    row: Math.floor(position / BOARD_SIZE),\r\n    col: position % BOARD_SIZE,\r\n  };\r\n};\r\n\r\n/**\r\n * Convert 2D coordinates to linear board position\r\n */\r\nexport const coordsToPosition = (row: number, col: number): BoardPosition => {\r\n  if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {\r\n    throw new Error(`Invalid coordinates: (${row}, ${col})`);\r\n  }\r\n  return row * BOARD_SIZE + col;\r\n};\r\n\r\n/**\r\n * Convert board position to pixel coordinates for rendering\r\n */\r\nexport const positionToPixel = (\r\n  position: BoardPosition,\r\n  cellSize: number,\r\n  boardOffset: Point = { x: 0, y: 0 },\r\n): Point => {\r\n  const coords = positionToCoords(position);\r\n  return {\r\n    x: boardOffset.x + coords.col * cellSize + cellSize / 2,\r\n    y: boardOffset.y + coords.row * cellSize + cellSize / 2,\r\n  };\r\n};\r\n\r\n/**\r\n * Convert pixel coordinates to board position\r\n */\r\nexport const pixelToPosition = (\r\n  pixel: Point,\r\n  cellSize: number,\r\n  boardOffset: Point = { x: 0, y: 0 },\r\n): BoardPosition | null => {\r\n  const col = Math.floor((pixel.x - boardOffset.x) / cellSize);\r\n  const row = Math.floor((pixel.y - boardOffset.y) / cellSize);\r\n\r\n  if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {\r\n    return null;\r\n  }\r\n\r\n  return coordsToPosition(row, col);\r\n};\r\n\r\n/**\r\n * Check if two positions are adjacent\r\n */\r\nexport const areAdjacent = (pos1: BoardPosition, pos2: BoardPosition): boolean => {\r\n  if (!isValidPosition(pos1) || !isValidPosition(pos2)) {\r\n    return false;\r\n  }\r\n\r\n  const coords1 = positionToCoords(pos1);\r\n  const coords2 = positionToCoords(pos2);\r\n\r\n  const rowDiff = Math.abs(coords1.row - coords2.row);\r\n  const colDiff = Math.abs(coords1.col - coords2.col);\r\n\r\n  return (rowDiff <= 1 && colDiff <= 1) && (rowDiff + colDiff > 0);\r\n};\r\n\r\n/**\r\n * Get distance between two positions\r\n */\r\nexport const getDistance = (pos1: BoardPosition, pos2: BoardPosition): number => {\r\n  const coords1 = positionToCoords(pos1);\r\n  const coords2 = positionToCoords(pos2);\r\n\r\n  return Math.max(\r\n    Math.abs(coords1.row - coords2.row),\r\n    Math.abs(coords1.col - coords2.col),\r\n  );\r\n};\r\n\r\n/**\r\n * Get all positions in a direction from a starting position\r\n */\r\nexport const getPositionsInDirection = (\r\n  start: BoardPosition,\r\n  direction: number,\r\n): BoardPosition[] => {\r\n  const positions: BoardPosition[] = [];\r\n  const startCoords = positionToCoords(start);\r\n\r\n  // Direction mappings: -9=NW, -8=N, -7=NE, -1=W, 1=E, 7=SW, 8=S, 9=SE\r\n  const dirRow = Math.floor(direction / 3) - 1;\r\n  const dirCol = (direction % 3) - 1;\r\n\r\n  let currentRow = startCoords.row + dirRow;\r\n  let currentCol = startCoords.col + dirCol;\r\n\r\n  while (currentRow >= 0 && currentRow < BOARD_SIZE &&\r\n         currentCol >= 0 && currentCol < BOARD_SIZE) {\r\n    positions.push(coordsToPosition(currentRow, currentCol));\r\n    currentRow += dirRow;\r\n    currentCol += dirCol;\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\n/**\r\n * Get all neighbors of a position\r\n */\r\nexport const getNeighbors = (position: BoardPosition): BoardPosition[] => {\r\n  const neighbors: BoardPosition[] = [];\r\n  const coords = positionToCoords(position);\r\n\r\n  for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {\r\n    for (let colOffset = -1; colOffset <= 1; colOffset++) {\r\n      if (rowOffset === 0 && colOffset === 0) {continue;}\r\n\r\n      const newRow = coords.row + rowOffset;\r\n      const newCol = coords.col + colOffset;\r\n\r\n      if (newRow >= 0 && newRow < BOARD_SIZE &&\r\n          newCol >= 0 && newCol < BOARD_SIZE) {\r\n        neighbors.push(coordsToPosition(newRow, newCol));\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/**\r\n * Get positions along the edges of the board\r\n */\r\nexport const getEdgePositions = (): BoardPosition[] => {\r\n  const edges: BoardPosition[] = [];\r\n\r\n  // Top and bottom rows\r\n  for (let col = 0; col < BOARD_SIZE; col++) {\r\n    edges.push(coordsToPosition(0, col));\r\n    edges.push(coordsToPosition(BOARD_SIZE - 1, col));\r\n  }\r\n\r\n  // Left and right columns (excluding corners already added)\r\n  for (let row = 1; row < BOARD_SIZE - 1; row++) {\r\n    edges.push(coordsToPosition(row, 0));\r\n    edges.push(coordsToPosition(row, BOARD_SIZE - 1));\r\n  }\r\n\r\n  return edges;\r\n};\r\n\r\n/**\r\n * Get corner positions\r\n */\r\nexport const getCornerPositions = (): BoardPosition[] => {\r\n  return [0, 7, 56, 63];\r\n};\r\n\r\n/**\r\n * Get positions that are diagonally adjacent to corners (X-squares)\r\n */\r\nexport const getXSquarePositions = (): BoardPosition[] => {\r\n  return [9, 14, 49, 54];\r\n};\r\n\r\n/**\r\n * Get positions that are adjacent to corners but not X-squares (C-squares)\r\n */\r\nexport const getCSquarePositions = (): BoardPosition[] => {\r\n  return [1, 6, 8, 15, 48, 55, 57, 62];\r\n};\r\n\r\n/**\r\n * Check if a position is on the board edge\r\n */\r\nexport const isOnEdge = (position: BoardPosition): boolean => {\r\n  const coords = positionToCoords(position);\r\n  return coords.row === 0 || coords.row === BOARD_SIZE - 1 ||\r\n         coords.col === 0 || coords.col === BOARD_SIZE - 1;\r\n};\r\n\r\n/**\r\n * Check if a position is a corner\r\n */\r\nexport const isCorner = (position: BoardPosition): boolean => {\r\n  return getCornerPositions().includes(position);\r\n};\r\n\r\n/**\r\n * Check if a position is an X-square (diagonal from corner)\r\n */\r\nexport const isXSquare = (position: BoardPosition): boolean => {\r\n  return getXSquarePositions().includes(position);\r\n};\r\n\r\n/**\r\n * Check if a position is a C-square (adjacent to corner)\r\n */\r\nexport const isCSquare = (position: BoardPosition): boolean => {\r\n  return getCSquarePositions().includes(position);\r\n};\r\n\r\n/**\r\n * Get the board notation for a position (e.g., \"a1\", \"h8\")\r\n */\r\nexport const getPositionNotation = (position: BoardPosition): string => {\r\n  const coords = positionToCoords(position);\r\n  const colLetter = String.fromCharCode(97 + coords.col); // 'a' + col\r\n  const rowNumber = coords.row + 1;\r\n  return `${colLetter}${rowNumber}`;\r\n};\r\n\r\n/**\r\n * Parse board notation to position\r\n */\r\nexport const parsePositionNotation = (notation: string): BoardPosition | null => {\r\n  if (notation.length !== 2) {return null;}\r\n\r\n  const colChar = notation.charAt(0).toLowerCase();\r\n  const rowChar = notation.charAt(1);\r\n\r\n  const col = colChar.charCodeAt(0) - 97; // 'a' = 0\r\n  const row = parseInt(rowChar, 10) - 1;\r\n\r\n  if (col < 0 || col >= BOARD_SIZE || row < 0 || row >= BOARD_SIZE || isNaN(row)) {\r\n    return null;\r\n  }\r\n\r\n  return coordsToPosition(row, col);\r\n};\r\n\r\n/**\r\n * Calculate direction between two positions\r\n */\r\nexport const getDirection = (from: BoardPosition, to: BoardPosition): number | null => {\r\n  const fromCoords = positionToCoords(from);\r\n  const toCoords = positionToCoords(to);\r\n\r\n  const rowDiff = toCoords.row - fromCoords.row;\r\n  const colDiff = toCoords.col - fromCoords.col;\r\n\r\n  // Normalize to -1, 0, 1\r\n  const normalizedRow = rowDiff === 0 ? 0 : (rowDiff > 0 ? 1 : -1);\r\n  const normalizedCol = colDiff === 0 ? 0 : (colDiff > 0 ? 1 : -1);\r\n\r\n  // Check if positions are in a straight line\r\n  if (rowDiff !== 0 && colDiff !== 0 && Math.abs(rowDiff) !== Math.abs(colDiff)) {\r\n    return null; // Not in a straight line\r\n  }\r\n\r\n  // Convert to direction index\r\n  return (normalizedRow + 1) * 3 + (normalizedCol + 1) - 4;\r\n};\r\n\r\n/**\r\n * Get all positions between two positions (exclusive)\r\n */\r\nexport const getPositionsBetween = (\r\n  from: BoardPosition,\r\n  to: BoardPosition,\r\n): BoardPosition[] | null => {\r\n  const direction = getDirection(from, to);\r\n  if (direction === null) {return null;}\r\n\r\n  const positions: BoardPosition[] = [];\r\n  const fromCoords = positionToCoords(from);\r\n  const toCoords = positionToCoords(to);\r\n\r\n  const rowStep = toCoords.row > fromCoords.row ? 1 : (toCoords.row < fromCoords.row ? -1 : 0);\r\n  const colStep = toCoords.col > fromCoords.col ? 1 : (toCoords.col < fromCoords.col ? -1 : 0);\r\n\r\n  let currentRow = fromCoords.row + rowStep;\r\n  let currentCol = fromCoords.col + colStep;\r\n\r\n  while (currentRow !== toCoords.row || currentCol !== toCoords.col) {\r\n    positions.push(coordsToPosition(currentRow, currentCol));\r\n    currentRow += rowStep;\r\n    currentCol += colStep;\r\n  }\r\n\r\n  return positions;\r\n};\r\n\r\n/**\r\n * Create empty board\r\n */\r\nexport const createEmptyBoard = (): Uint8Array => {\r\n  return new Uint8Array(TOTAL_SQUARES);\r\n};\r\n\r\n/**\r\n * Create initial Reversi board setup\r\n */\r\nexport const createInitialBoard = (): Uint8Array => {\r\n  const board = createEmptyBoard();\r\n\r\n  // Standard Reversi starting position\r\n  board[coordsToPosition(3, 3)] = PlayerColor.WHITE;\r\n  board[coordsToPosition(3, 4)] = PlayerColor.BLACK;\r\n  board[coordsToPosition(4, 3)] = PlayerColor.BLACK;\r\n  board[coordsToPosition(4, 4)] = PlayerColor.WHITE;\r\n\r\n  return board;\r\n};\r\n\r\n/**\r\n * Clone board state\r\n */\r\nexport const cloneBoard = (board: Uint8Array): Uint8Array => {\r\n  return new Uint8Array(board);\r\n};\r\n\r\n/**\r\n * Count pieces of each color on the board\r\n */\r\nexport const countPieces = (board: Uint8Array): { black: number; white: number; empty: number } => {\r\n  let black = 0;\r\n  let white = 0;\r\n  let empty = 0;\r\n\r\n  for (let i = 0; i < TOTAL_SQUARES; i++) {\r\n    switch (board[i]) {\r\n      case PlayerColor.BLACK:\r\n        black++;\r\n        break;\r\n      case PlayerColor.WHITE:\r\n        white++;\r\n        break;\r\n      case PlayerColor.EMPTY:\r\n        empty++;\r\n        break;\r\n    }\r\n  }\r\n\r\n  return { black, white, empty };\r\n};\r\n\r\n/**\r\n * Get all positions occupied by a specific color\r\n */\r\nexport const getPositionsOfColor = (board: Uint8Array, color: PlayerColor): BoardPosition[] => {\r\n  const positions: BoardPosition[] = [];\r\n  for (let i = 0; i < TOTAL_SQUARES; i++) {\r\n    if (board[i] === color) {\r\n      positions.push(i);\r\n    }\r\n  }\r\n  return positions;\r\n};\r\n\r\n/**\r\n * Check if board is full\r\n */\r\nexport const isBoardFull = (board: Uint8Array): boolean => {\r\n  return !board.includes(PlayerColor.EMPTY);\r\n};\r\n\r\n/**\r\n * Convert board to string representation for debugging\r\n */\r\nexport const boardToString = (board: Uint8Array): string => {\r\n  let result = '  a b c d e f g h\\n';\r\n  for (let row = 0; row < BOARD_SIZE; row++) {\r\n    result += `${row + 1} `;\r\n    for (let col = 0; col < BOARD_SIZE; col++) {\r\n      const position = coordsToPosition(row, col);\r\n      const piece = board[position];\r\n      let symbol = '.';\r\n      if (piece === PlayerColor.BLACK) {symbol = '●';}\r\n      if (piece === PlayerColor.WHITE) {symbol = '○';}\r\n      result += symbol + ' ';\r\n    }\r\n    result += `${row + 1}\\n`;\r\n  }\r\n  result += '  a b c d e f g h\\n';\r\n  return result;\r\n};","/**\r\n * Move Validation Logic\r\n *\r\n * Handles validation of Reversi moves including:\r\n * - Legal move checking\r\n * - Piece flipping calculation\r\n * - Valid move generation\r\n */\r\n\r\nimport {\r\n  BoardPosition,\r\n  PlayerColor,\r\n  BOARD_SIZE,\r\n  TOTAL_SQUARES,\r\n  InvalidMoveError,\r\n} from '@/types/game-types';\r\nimport { positionToCoords } from './board-utils';\r\n\r\n/**\r\n * Validation result for a move attempt\r\n */\r\nexport interface MoveValidationResult {\r\n  isValid: boolean;\r\n  flippedPositions: BoardPosition[];\r\n  reason?: string;\r\n}\r\n\r\n/**\r\n * Check if a move is legal and return flipped positions\r\n */\r\nexport const validateMove = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): MoveValidationResult => {\r\n  // Position must be empty\r\n  if (board[position] !== PlayerColor.EMPTY) {\r\n    return {\r\n      isValid: false,\r\n      flippedPositions: [],\r\n      reason: 'Position is already occupied',\r\n    };\r\n  }\r\n\r\n  // Position must be on the board\r\n  if (position < 0 || position >= TOTAL_SQUARES) {\r\n    return {\r\n      isValid: false,\r\n      flippedPositions: [],\r\n      reason: 'Position is outside the board',\r\n    };\r\n  }\r\n\r\n  const flippedPositions = calculateFlips(board, position, player);\r\n\r\n  if (flippedPositions.length === 0) {\r\n    return {\r\n      isValid: false,\r\n      flippedPositions: [],\r\n      reason: 'Move does not flip any opponent pieces',\r\n    };\r\n  }\r\n\r\n  return {\r\n    isValid: true,\r\n    flippedPositions,\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate which pieces would be flipped by a move\r\n */\r\nexport const calculateFlips = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): BoardPosition[] => {\r\n  const allFlips: BoardPosition[] = [];\r\n  const opponent = player === PlayerColor.BLACK ? PlayerColor.WHITE : PlayerColor.BLACK;\r\n\r\n  // All 8 directions: N, NE, E, SE, S, SW, W, NW\r\n  const directions = [\r\n    { row: -1, col: 0 },  // N\r\n    { row: -1, col: 1 },  // NE\r\n    { row: 0, col: 1 },   // E\r\n    { row: 1, col: 1 },   // SE\r\n    { row: 1, col: 0 },   // S\r\n    { row: 1, col: -1 },  // SW\r\n    { row: 0, col: -1 },  // W\r\n    { row: -1, col: -1 }, // NW\r\n  ];\r\n\r\n  const startCoords = positionToCoords(position);\r\n\r\n  for (const direction of directions) {\r\n    const flipsInDirection = calculateFlipsInDirection(\r\n      board,\r\n      startCoords,\r\n      direction,\r\n      player,\r\n      opponent,\r\n    );\r\n    allFlips.push(...flipsInDirection);\r\n  }\r\n\r\n  return allFlips;\r\n};\r\n\r\n/**\r\n * Calculate flips in a specific direction\r\n */\r\nfunction calculateFlipsInDirection(\r\n  board: Uint8Array,\r\n  startCoords: { row: number; col: number },\r\n  direction: { row: number; col: number },\r\n  player: PlayerColor,\r\n  opponent: PlayerColor,\r\n): BoardPosition[] {\r\n  const flips: BoardPosition[] = [];\r\n  let currentRow = startCoords.row + direction.row;\r\n  let currentCol = startCoords.col + direction.col;\r\n\r\n  // First, collect all consecutive opponent pieces\r\n  while (\r\n    currentRow >= 0 && currentRow < BOARD_SIZE &&\r\n    currentCol >= 0 && currentCol < BOARD_SIZE\r\n  ) {\r\n    const currentPosition = currentRow * BOARD_SIZE + currentCol;\r\n    const currentPiece = board[currentPosition];\r\n\r\n    if (currentPiece === opponent) {\r\n      // Found opponent piece, add to potential flips\r\n      flips.push(currentPosition);\r\n    } else if (currentPiece === player) {\r\n      // Found our piece - flips are valid if we have opponent pieces between\r\n      return flips.length > 0 ? flips : [];\r\n    } else {\r\n      // Found empty square - no valid flips in this direction\r\n      return [];\r\n    }\r\n\r\n    currentRow += direction.row;\r\n    currentCol += direction.col;\r\n  }\r\n\r\n  // Reached edge of board without finding our piece - no valid flips\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get all valid moves for a player\r\n */\r\nexport const getValidMoves = (\r\n  board: Uint8Array,\r\n  player: PlayerColor,\r\n): Map<BoardPosition, BoardPosition[]> => {\r\n  const validMoves = new Map<BoardPosition, BoardPosition[]>();\r\n\r\n  for (let position = 0; position < TOTAL_SQUARES; position++) {\r\n    if (board[position] === PlayerColor.EMPTY) {\r\n      const result = validateMove(board, position, player);\r\n      if (result.isValid) {\r\n        validMoves.set(position, result.flippedPositions);\r\n      }\r\n    }\r\n  }\r\n\r\n  return validMoves;\r\n};\r\n\r\n/**\r\n * Check if a player has any valid moves\r\n */\r\nexport const hasValidMoves = (board: Uint8Array, player: PlayerColor): boolean => {\r\n  for (let position = 0; position < TOTAL_SQUARES; position++) {\r\n    if (board[position] === PlayerColor.EMPTY) {\r\n      const result = validateMove(board, position, player);\r\n      if (result.isValid) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Apply a move to the board (creates new board state)\r\n */\r\nexport const applyMove = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n  flippedPositions: BoardPosition[],\r\n): Uint8Array => {\r\n  const newBoard = new Uint8Array(board);\r\n\r\n  // Place the new piece\r\n  newBoard[position] = player;\r\n\r\n  // Flip all the captured pieces\r\n  for (const flipPosition of flippedPositions) {\r\n    newBoard[flipPosition] = player;\r\n  }\r\n\r\n  return newBoard;\r\n};\r\n\r\n/**\r\n * Validate and apply a move in one step\r\n */\r\nexport const makeMove = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): { newBoard: Uint8Array; flippedPositions: BoardPosition[] } => {\r\n  const validation = validateMove(board, position, player);\r\n\r\n  if (!validation.isValid) {\r\n    throw new InvalidMoveError(\r\n      validation.reason || 'Invalid move',\r\n      position,\r\n      'invalid_move',\r\n    );\r\n  }\r\n\r\n  const newBoard = applyMove(board, position, player, validation.flippedPositions);\r\n\r\n  return {\r\n    newBoard,\r\n    flippedPositions: validation.flippedPositions,\r\n  };\r\n};\r\n\r\n/**\r\n * Check if game is over (no moves for either player)\r\n */\r\nexport const isGameOver = (board: Uint8Array): boolean => {\r\n  return !hasValidMoves(board, PlayerColor.BLACK) && !hasValidMoves(board, PlayerColor.WHITE);\r\n};\r\n\r\n/**\r\n * Get game winner based on current board state\r\n */\r\nexport const getWinner = (board: Uint8Array): PlayerColor | 'tie' | null => {\r\n  if (!isGameOver(board)) {\r\n    return null; // Game not over yet\r\n  }\r\n\r\n  let blackCount = 0;\r\n  let whiteCount = 0;\r\n\r\n  for (let i = 0; i < TOTAL_SQUARES; i++) {\r\n    if (board[i] === PlayerColor.BLACK) {\r\n      blackCount++;\r\n    } else if (board[i] === PlayerColor.WHITE) {\r\n      whiteCount++;\r\n    }\r\n  }\r\n\r\n  if (blackCount > whiteCount) {\r\n    return PlayerColor.BLACK;\r\n  } else if (whiteCount > blackCount) {\r\n    return PlayerColor.WHITE;\r\n  } else {\r\n    return 'tie';\r\n  }\r\n};\r\n\r\n/**\r\n * Check if a position is a corner move\r\n */\r\nexport const isCornerMove = (position: BoardPosition): boolean => {\r\n  return [0, 7, 56, 63].includes(position);\r\n};\r\n\r\n/**\r\n * Check if a position is an edge move\r\n */\r\nexport const isEdgeMove = (position: BoardPosition): boolean => {\r\n  const coords = positionToCoords(position);\r\n  return coords.row === 0 || coords.row === 7 || coords.col === 0 || coords.col === 7;\r\n};\r\n\r\n/**\r\n * Check if a position is adjacent to a corner (dangerous X-square)\r\n */\r\nexport const isXSquareMove = (position: BoardPosition): boolean => {\r\n  return [9, 14, 49, 54].includes(position);\r\n};\r\n\r\n/**\r\n * Check if a position is next to a corner (C-square)\r\n */\r\nexport const isCSquareMove = (position: BoardPosition): boolean => {\r\n  return [1, 6, 8, 15, 48, 55, 57, 62].includes(position);\r\n};\r\n\r\n/**\r\n * Calculate mobility (number of valid moves) for a player after a hypothetical move\r\n */\r\nexport const calculateMobility = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): { playerMobility: number; opponentMobility: number } => {\r\n  // Apply the hypothetical move\r\n  const validation = validateMove(board, position, player);\r\n  if (!validation.isValid) {\r\n    return { playerMobility: 0, opponentMobility: 0 };\r\n  }\r\n\r\n  const newBoard = applyMove(board, position, player, validation.flippedPositions);\r\n  const opponent = player === PlayerColor.BLACK ? PlayerColor.WHITE : PlayerColor.BLACK;\r\n\r\n  const playerMoves = getValidMoves(newBoard, player);\r\n  const opponentMoves = getValidMoves(newBoard, opponent);\r\n\r\n  return {\r\n    playerMobility: playerMoves.size,\r\n    opponentMobility: opponentMoves.size,\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate stability score for a position (rough estimate)\r\n */\r\nexport const calculateStability = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): number => {\r\n  let stability = 0;\r\n  const coords = positionToCoords(position);\r\n\r\n  // Corner pieces are completely stable\r\n  if (isCornerMove(position)) {\r\n    return 10;\r\n  }\r\n\r\n  // Edge pieces have some stability\r\n  if (isEdgeMove(position)) {\r\n    stability += 3;\r\n  }\r\n\r\n  // Check if piece is protected by friendly pieces in multiple directions\r\n  const directions = [\r\n    { row: -1, col: 0 }, { row: -1, col: 1 }, { row: 0, col: 1 }, { row: 1, col: 1 },\r\n    { row: 1, col: 0 }, { row: 1, col: -1 }, { row: 0, col: -1 }, { row: -1, col: -1 },\r\n  ];\r\n\r\n  let protectedDirections = 0;\r\n  for (const dir of directions) {\r\n    const newRow = coords.row + dir.row;\r\n    const newCol = coords.col + dir.col;\r\n\r\n    if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {\r\n      const neighborPos = newRow * BOARD_SIZE + newCol;\r\n      if (board[neighborPos] === player) {\r\n        protectedDirections++;\r\n      }\r\n    }\r\n  }\r\n\r\n  stability += Math.floor(protectedDirections / 2);\r\n  return stability;\r\n};","/**\r\n * Move Scoring System\r\n *\r\n * Evaluates move quality and assigns scores/grades based on:\r\n * - Position value (corners, edges, X-squares, etc.)\r\n * - Number of pieces flipped\r\n * - Stability bonus\r\n * - Mobility impact\r\n */\r\n\r\nimport {\r\n  BoardPosition,\r\n  PlayerColor,\r\n  Grade,\r\n  GRADE_THRESHOLDS,\r\n  POSITION_VALUES,\r\n} from '@/types/game-types';\r\nimport type { MoveScore, ScoreBreakdown } from '@/core/models/Move';\r\nimport {\r\n  isCornerMove,\r\n  isEdgeMove,\r\n  isXSquareMove,\r\n  isCSquareMove,\r\n  calculateMobility,\r\n  calculateStability,\r\n} from './move-validator';\r\n\r\n/**\r\n * Evaluate a move and return its score and grade\r\n */\r\nexport const evaluateMove = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n  flippedPositions: BoardPosition[],\r\n): MoveScore => {\r\n  const breakdown = calculateScoreBreakdown(board, position, player, flippedPositions);\r\n  const grade = calculateGrade(breakdown.total);\r\n\r\n  return {\r\n    points: breakdown.total,\r\n    grade,\r\n    breakdown: Object.freeze(breakdown),\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate detailed score breakdown for a move\r\n */\r\nexport const calculateScoreBreakdown = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n  flippedPositions: BoardPosition[],\r\n): ScoreBreakdown => {\r\n  const positionValue = calculatePositionValue(position);\r\n  const flippedCount = flippedPositions.length;\r\n  const stabilityBonus = calculateStabilityBonus(board, position, player, flippedPositions);\r\n  const mobilityFactor = calculateMobilityFactor(board, position, player);\r\n\r\n  // Base score calculation including mobility difference\r\n  let baseScore = positionValue + flippedCount + stabilityBonus;\r\n\r\n  // Add mobility factor (difference between player and opponent mobility)\r\n  const total = Math.max(0, Math.floor(baseScore + mobilityFactor));\r\n\r\n  return {\r\n    positionValue,\r\n    flippedCount,\r\n    stabilityBonus,\r\n    mobilityFactor,\r\n    total,\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate position value based on strategic importance\r\n */\r\nexport const calculatePositionValue = (position: BoardPosition): number => {\r\n  if (isCornerMove(position)) {\r\n    return POSITION_VALUES.CORNER; // 25 points - extremely valuable\r\n  }\r\n\r\n  if (isXSquareMove(position)) {\r\n    return POSITION_VALUES.X_SQUARE; // -10 points - dangerous, gives opponent corner access\r\n  }\r\n\r\n  if (isCSquareMove(position)) {\r\n    return POSITION_VALUES.C_SQUARE; // -6 points - somewhat dangerous\r\n  }\r\n\r\n  if (isEdgeMove(position)) {\r\n    return POSITION_VALUES.EDGE; // 6 points - good for stability\r\n  }\r\n\r\n  return POSITION_VALUES.NORMAL; // 0 points - neutral position\r\n};\r\n\r\n/**\r\n * Calculate stability bonus for pieces that will become stable\r\n */\r\nexport const calculateStabilityBonus = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n  flippedPositions: BoardPosition[],\r\n): number => {\r\n  let stabilityBonus = 0;\r\n\r\n  // Bonus for the placed piece\r\n  const placedStability = calculateStability(board, position, player);\r\n  stabilityBonus += placedStability;\r\n\r\n  // Bonus for newly stable flipped pieces\r\n  for (const flippedPos of flippedPositions) {\r\n    const flippedStability = calculateStability(board, flippedPos, player);\r\n    stabilityBonus += Math.floor(flippedStability / 2); // Half value for flipped pieces\r\n  }\r\n\r\n  return stabilityBonus;\r\n};\r\n\r\n/**\r\n * Calculate mobility factor as the direct difference between player and opponent mobility\r\n */\r\nexport const calculateMobilityFactor = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  player: PlayerColor,\r\n): number => {\r\n  const mobility = calculateMobility(board, position, player);\r\n  const mobilityDifference = mobility.playerMobility - mobility.opponentMobility;\r\n\r\n  // Return the direct difference (subtraction result)\r\n  return mobilityDifference;\r\n};\r\n\r\n/**\r\n * Determine grade based on total score\r\n */\r\nexport const calculateGrade = (score: number): Grade => {\r\n  if (score >= GRADE_THRESHOLDS.SSS) {\r\n    return Grade.SSS; // 60+ points\r\n  } else if (score >= GRADE_THRESHOLDS.SS) {\r\n    return Grade.SS; // 45-59 points\r\n  } else if (score >= GRADE_THRESHOLDS.S) {\r\n    return Grade.S; // 30-44 points\r\n  } else if (score >= GRADE_THRESHOLDS.A) {\r\n    return Grade.A; // 18-29 points\r\n  } else if (score >= GRADE_THRESHOLDS.B) {\r\n    return Grade.B; // 10-17 points\r\n  } else {\r\n    return Grade.C; // 0-9 points\r\n  }\r\n};\r\n\r\n/**\r\n * Quick evaluation for AI move sorting (simplified version)\r\n */\r\nexport const quickEvaluateMove = (\r\n  _board: Uint8Array,\r\n  position: BoardPosition,\r\n  _player: PlayerColor,\r\n  flippedPositions: BoardPosition[],\r\n): number => {\r\n  const positionValue = calculatePositionValue(position);\r\n  const flippedCount = flippedPositions.length;\r\n\r\n  // Simplified calculation for performance\r\n  return positionValue + flippedCount + (isCornerMove(position) ? 10 : 0);\r\n};\r\n\r\n/**\r\n * Evaluate all valid moves and return sorted by score\r\n */\r\nexport const evaluateAllMoves = (\r\n  board: Uint8Array,\r\n  validMoves: Map<BoardPosition, readonly BoardPosition[]> | Map<BoardPosition, BoardPosition[]>,\r\n  player: PlayerColor,\r\n): Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }> => {\r\n  const evaluatedMoves: Array<{\r\n    position: BoardPosition;\r\n    score: MoveScore;\r\n    flippedPositions: BoardPosition[];\r\n  }> = [];\r\n\r\n  for (const [position, flippedPositions] of validMoves.entries()) {\r\n    const score = evaluateMove(board, position, player, [...flippedPositions]);\r\n    evaluatedMoves.push({ position, score, flippedPositions: [...flippedPositions] });\r\n  }\r\n\r\n  // Sort by score descending (best moves first)\r\n  return evaluatedMoves.sort((a, b) => b.score.points - a.score.points);\r\n};\r\n\r\n/**\r\n * Get moves above a certain grade threshold\r\n */\r\nexport const getMovesAboveGrade = (\r\n  evaluatedMoves: Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }>,\r\n  minGrade: Grade,\r\n): Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }> => {\r\n  const gradeValues = {\r\n    [Grade.C]: 1,\r\n    [Grade.B]: 2,\r\n    [Grade.A]: 3,\r\n    [Grade.S]: 4,\r\n    [Grade.SS]: 5,\r\n    [Grade.SSS]: 6,\r\n  };\r\n  const minValue = gradeValues[minGrade];\r\n\r\n  return evaluatedMoves.filter(move => gradeValues[move.score.grade] >= minValue);\r\n};\r\n\r\n/**\r\n * Get the best move from a list of evaluated moves\r\n */\r\nexport const getBestMove = (\r\n  evaluatedMoves: Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }>,\r\n): { position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] } | null => {\r\n  if (evaluatedMoves.length === 0) {return null;}\r\n\r\n  // Find highest scoring move\r\n  let bestMove = evaluatedMoves[0]!;\r\n  for (const move of evaluatedMoves) {\r\n    if (move.score.points > bestMove.score.points) {\r\n      bestMove = move;\r\n    }\r\n  }\r\n\r\n  return bestMove;\r\n};\r\n\r\n/**\r\n * Get moves of a specific grade\r\n */\r\nexport const getMovesByGrade = (\r\n  evaluatedMoves: Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }>,\r\n  grade: Grade,\r\n): Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }> => {\r\n  return evaluatedMoves.filter(move => move.score.grade === grade);\r\n};\r\n\r\n/**\r\n * Calculate average score of all moves\r\n */\r\nexport const calculateAverageScore = (\r\n  evaluatedMoves: Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }>,\r\n): number => {\r\n  if (evaluatedMoves.length === 0) {return 0;}\r\n\r\n  const totalScore = evaluatedMoves.reduce((sum, move) => sum + move.score.points, 0);\r\n  return totalScore / evaluatedMoves.length;\r\n};\r\n\r\n/**\r\n * Get grade distribution for analytics\r\n */\r\nexport const getGradeDistribution = (\r\n  evaluatedMoves: Array<{ position: BoardPosition; score: MoveScore; flippedPositions: BoardPosition[] }>,\r\n): Record<Grade, number> => {\r\n  const distribution: Record<Grade, number> = {\r\n    [Grade.C]: 0,\r\n    [Grade.B]: 0,\r\n    [Grade.A]: 0,\r\n    [Grade.S]: 0,\r\n    [Grade.SS]: 0,\r\n    [Grade.SSS]: 0,\r\n  };\r\n\r\n  for (const move of evaluatedMoves) {\r\n    distribution[move.score.grade]++;\r\n  }\r\n\r\n  return distribution;\r\n};\r\n\r\n/**\r\n * Check if a move qualifies for bonus effects (high flip count)\r\n */\r\nexport const shouldTriggerBonusEffects = (flippedCount: number): boolean => {\r\n  return flippedCount >= 16; // Massive flip bonus\r\n};\r\n\r\n/**\r\n * Calculate endgame scoring adjustments\r\n */\r\nexport const calculateEndgameAdjustment = (\r\n  board: Uint8Array,\r\n  position: BoardPosition,\r\n  _player: PlayerColor,\r\n): number => {\r\n  let emptySquares = 0;\r\n  for (let i = 0; i < board.length; i++) {\r\n    if (board[i] === PlayerColor.EMPTY) {\r\n      emptySquares++;\r\n    }\r\n  }\r\n\r\n  // In endgame (< 16 empty squares), prioritize flipping count over position\r\n  if (emptySquares < 16) {\r\n    return isCornerMove(position) ? 5 : 0; // Reduced corner bonus\r\n  }\r\n\r\n  return 0; // No adjustment in early/mid game\r\n};\r\n\r\n/**\r\n * Format score for display\r\n */\r\nexport const formatScore = (score: MoveScore): string => {\r\n  return `${score.grade}-${score.points}`;\r\n};\r\n\r\n/**\r\n * Format score breakdown for detailed display\r\n */\r\nexport const formatBreakdown = (breakdown: ScoreBreakdown): string => {\r\n  return [\r\n    `Position: ${breakdown.positionValue >= 0 ? '+' : ''}${breakdown.positionValue}`,\r\n    `Flipped: +${breakdown.flippedCount}`,\r\n    `Stability: +${breakdown.stabilityBonus}`,\r\n    `Mobility: ${breakdown.mobilityFactor > 0 ? '+' : ''}${breakdown.mobilityFactor}`,\r\n    `Total: ${breakdown.total}`,\r\n  ].join(' | ');\r\n};","/**\r\n * Greedy AI Strategy (v1)\r\n *\r\n * AI implementation that selects moves based on immediate score evaluation.\r\n * Uses the move evaluation system to pick the highest-scoring move available.\r\n * Target response time: ~1 second for thorough evaluation.\r\n */\r\n\r\nimport { AIDifficulty, PlayerColor, BoardPosition } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\nimport { AIStrategyBase, type AIMoveResult, AIUtils } from '../ai-strategy-base';\r\nimport { evaluateAllMoves, getBestMove } from '@/core/utils/move-evaluator';\r\nimport { Grade } from '@/types/game-types';\r\n\r\n/**\r\n * Greedy AI implementation\r\n */\r\nexport class GreedyAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.GREEDY;\r\n  public readonly name = 'Greedy AI';\r\n  public readonly description = 'Selects moves with highest immediate score';\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n\r\n    // Get all valid moves and evaluate them\r\n    const evaluatedMoves = evaluateAllMoves(gameState.board as Uint8Array, new Map(gameState.validMoves), player);\r\n\r\n    if (evaluatedMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    // Simulate thinking time (but be efficient)\r\n    const thinkingTime = Math.min(500 + Math.random() * 300, timeLimit * 0.8); // 500-800ms\r\n    const remainingTime = thinkingTime - (Date.now() - startTime);\r\n\r\n    if (remainingTime > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, remainingTime));\r\n    }\r\n\r\n    // Get the best move\r\n    const bestMove = getBestMove(evaluatedMoves);\r\n\r\n    if (!bestMove) {\r\n      throw new Error('Could not determine best move');\r\n    }\r\n\r\n    // Calculate confidence based on move quality and competition\r\n    const confidence = this.calculateConfidence(evaluatedMoves, bestMove);\r\n\r\n    return {\r\n      position: bestMove.position,\r\n      confidence,\r\n      evaluation: bestMove.score.points,\r\n      thinkingTime: Date.now() - startTime,\r\n      depth: 1, // Only evaluates immediate moves\r\n      nodesEvaluated: evaluatedMoves.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence based on move quality and alternatives\r\n   */\r\n  private calculateConfidence(\r\n    evaluatedMoves: Array<{ position: BoardPosition; score: any; flippedPositions: BoardPosition[] }>,\r\n    bestMove: { position: BoardPosition; score: any; flippedPositions: BoardPosition[] },\r\n  ): number {\r\n    if (evaluatedMoves.length === 1) {\r\n      return 0.9; // High confidence when only one move\r\n    }\r\n\r\n    // Base confidence from move grade\r\n    let confidence = 0.3; // Start with moderate confidence\r\n\r\n    switch (bestMove.score.grade) {\r\n      case Grade.S:\r\n        confidence = 0.95;\r\n        break;\r\n      case Grade.A:\r\n        confidence = 0.8;\r\n        break;\r\n      case Grade.B:\r\n        confidence = 0.6;\r\n        break;\r\n      case Grade.C:\r\n        confidence = 0.3;\r\n        break;\r\n    }\r\n\r\n    // Adjust based on score gap to second-best move\r\n    const sortedMoves = [...evaluatedMoves].sort((a, b) => b.score.points - a.score.points);\r\n    if (sortedMoves.length > 1) {\r\n      const scoreGap = sortedMoves[0]!.score.points - sortedMoves[1]!.score.points;\r\n\r\n      if (scoreGap > 15) {\r\n        confidence += 0.15; // Clear winner\r\n      } else if (scoreGap > 5) {\r\n        confidence += 0.05; // Moderate advantage\r\n      } else {\r\n        confidence -= 0.1; // Close competition\r\n      }\r\n    }\r\n\r\n    return Math.max(0.1, Math.min(0.95, confidence));\r\n  }\r\n}\r\n\r\n/**\r\n * Enhanced Greedy AI with additional heuristics\r\n */\r\nexport class EnhancedGreedyAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.GREEDY;\r\n  public readonly name = 'Enhanced Greedy AI';\r\n  public readonly description = 'Greedy with additional strategic considerations';\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n\r\n    const evaluatedMoves = evaluateAllMoves(gameState.board as Uint8Array, new Map(gameState.validMoves), player);\r\n\r\n    if (evaluatedMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    // Apply additional heuristics\r\n    const enhancedMoves = evaluatedMoves.map(move => ({\r\n      ...move,\r\n      enhancedScore: this.calculateEnhancedScore(gameState, move, player),\r\n    }));\r\n\r\n    // Sort by enhanced score\r\n    enhancedMoves.sort((a, b) => b.enhancedScore - a.enhancedScore);\r\n\r\n    // Consider top candidates with similar scores\r\n    const bestScore = enhancedMoves[0]!.enhancedScore;\r\n    const threshold = bestScore * 0.9; // Within 10% of best\r\n    const topCandidates = enhancedMoves.filter(move => move.enhancedScore >= threshold);\r\n\r\n    // Add some randomization among top candidates to avoid predictability\r\n    const selectedMove = AIUtils.selectWeightedRandom(\r\n      topCandidates.map(move => ({ ...move, score: move.enhancedScore })),\r\n      2.0, // Temperature for selection\r\n    );\r\n\r\n    // Simulate thinking time\r\n    const targetThinkingTime = Math.min(600 + Math.random() * 400, timeLimit * 0.9);\r\n    const remainingTime = targetThinkingTime - (Date.now() - startTime);\r\n\r\n    if (remainingTime > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, remainingTime));\r\n    }\r\n\r\n    const confidence = this.calculateEnhancedConfidence(topCandidates, selectedMove);\r\n\r\n    return {\r\n      position: selectedMove.position,\r\n      confidence,\r\n      evaluation: selectedMove.enhancedScore,\r\n      thinkingTime: Date.now() - startTime,\r\n      depth: 1,\r\n      nodesEvaluated: evaluatedMoves.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate enhanced score with additional heuristics\r\n   */\r\n  private calculateEnhancedScore(\r\n    gameState: GameState,\r\n    move: { position: BoardPosition; score: any; flippedPositions: BoardPosition[] },\r\n    player: PlayerColor,\r\n  ): number {\r\n    let score = move.score.points;\r\n\r\n    // Game phase consideration\r\n    const gamePhase = AIUtils.getGamePhase(gameState);\r\n\r\n    if (gamePhase > 0.7) {\r\n      // Endgame: prioritize flipped pieces over position\r\n      score += move.flippedPositions.length * 2;\r\n    } else if (gamePhase < 0.3) {\r\n      // Early game: be more careful about dangerous positions\r\n      if (AIUtils.isDangerousPosition(move.position)) {\r\n        score -= 5;\r\n      }\r\n    }\r\n\r\n    // Stability consideration\r\n    const stability = AIUtils.evaluatePositionStability(gameState, move.position, player);\r\n    score += stability;\r\n\r\n    // Mobility preservation (don't give opponent too many options)\r\n    const opponent = player === PlayerColor.BLACK ? PlayerColor.WHITE : PlayerColor.BLACK;\r\n    const currentMobility = AIUtils.calculateMobility(gameState, opponent);\r\n\r\n    // Slightly prefer moves that don't dramatically increase opponent mobility\r\n    if (currentMobility < 3) {\r\n      score += 2; // Bonus for limiting opponent when they're already constrained\r\n    }\r\n\r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence for enhanced AI\r\n   */\r\n  private calculateEnhancedConfidence(\r\n    topCandidates: any[],\r\n    selectedMove: any,\r\n  ): number {\r\n    let confidence = 0.6; // Base confidence for enhanced greedy\r\n\r\n    // Confidence increases if we have fewer but stronger candidates\r\n    if (topCandidates.length === 1) {\r\n      confidence = 0.9;\r\n    } else if (topCandidates.length <= 3) {\r\n      confidence = 0.8;\r\n    }\r\n\r\n    // Adjust based on selected move grade\r\n    if (selectedMove.score?.grade) {\r\n      switch (selectedMove.score.grade) {\r\n        case Grade.S:\r\n          confidence = Math.max(confidence, 0.9);\r\n          break;\r\n        case Grade.A:\r\n          confidence = Math.max(confidence, 0.75);\r\n          break;\r\n        case Grade.B:\r\n          confidence = Math.max(confidence, 0.6);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return Math.max(0.2, Math.min(0.95, confidence));\r\n  }\r\n}\r\n\r\n/**\r\n * Adaptive Greedy AI that adjusts strategy based on game situation\r\n */\r\nexport class AdaptiveGreedyAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.GREEDY;\r\n  public readonly name = 'Adaptive Greedy AI';\r\n  public readonly description = 'Greedy AI that adapts strategy to game phase and score';\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n\r\n    const evaluatedMoves = evaluateAllMoves(gameState.board as Uint8Array, new Map(gameState.validMoves), player);\r\n\r\n    if (evaluatedMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    // Determine strategy based on game situation\r\n    const strategy = this.determineStrategy(gameState, player);\r\n\r\n    // Apply strategy-specific evaluation\r\n    const strategicMoves = evaluatedMoves.map(move => ({\r\n      ...move,\r\n      strategicScore: this.calculateStrategicScore(gameState, move, player, strategy),\r\n    }));\r\n\r\n    strategicMoves.sort((a, b) => b.strategicScore - a.strategicScore);\r\n\r\n    // Select best move with some randomization based on strategy\r\n    const selectionTemperature = this.getSelectionTemperature(strategy);\r\n    const topMoves = strategicMoves.slice(0, Math.min(5, strategicMoves.length));\r\n\r\n    const selectedMove = AIUtils.selectWeightedRandom(\r\n      topMoves.map(move => ({ ...move, score: move.strategicScore })),\r\n      selectionTemperature,\r\n    );\r\n\r\n    // Adaptive thinking time based on situation complexity\r\n    const adaptiveThinkingTime = this.calculateAdaptiveThinkingTime(\r\n      gameState,\r\n      evaluatedMoves.length,\r\n      strategy,\r\n      timeLimit,\r\n    );\r\n\r\n    const remainingTime = adaptiveThinkingTime - (Date.now() - startTime);\r\n    if (remainingTime > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, remainingTime));\r\n    }\r\n\r\n    return {\r\n      position: selectedMove.position,\r\n      confidence: this.calculateAdaptiveConfidence(strategy, selectedMove, topMoves),\r\n      evaluation: selectedMove.strategicScore,\r\n      thinkingTime: Date.now() - startTime,\r\n      depth: 1,\r\n      nodesEvaluated: evaluatedMoves.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Determine strategy based on game situation\r\n   */\r\n  private determineStrategy(gameState: GameState, player: PlayerColor): string {\r\n    const gamePhase = AIUtils.getGamePhase(gameState);\r\n    const myScore = player === PlayerColor.BLACK ? gameState.scores.black : gameState.scores.white;\r\n    const opponentScore = player === PlayerColor.BLACK ? gameState.scores.white : gameState.scores.black;\r\n    const scoreDifference = myScore - opponentScore;\r\n    const mobility = gameState.validMoves.size;\r\n\r\n    // Endgame strategy\r\n    if (gamePhase > 0.8) {\r\n      return scoreDifference > 0 ? 'endgame_ahead' : 'endgame_behind';\r\n    }\r\n\r\n    // Mid-game strategies\r\n    if (gamePhase > 0.4) {\r\n      if (scoreDifference > 5) {return 'consolidate';}\r\n      if (scoreDifference < -5) {return 'aggressive';}\r\n      if (mobility < 3) {return 'careful';}\r\n      return 'balanced';\r\n    }\r\n\r\n    // Early game strategies\r\n    if (mobility > 8) {return 'opportunistic';}\r\n    return 'cautious';\r\n  }\r\n\r\n  private calculateStrategicScore(\r\n    gameState: GameState,\r\n    move: any,\r\n    player: PlayerColor,\r\n    strategy: string,\r\n  ): number {\r\n    let score = move.score.points;\r\n    AIUtils.getGamePhase(gameState);\r\n\r\n    switch (strategy) {\r\n      case 'endgame_ahead':\r\n        // When ahead in endgame, maximize piece count\r\n        score += move.flippedPositions.length * 3;\r\n        break;\r\n\r\n      case 'endgame_behind':\r\n        // When behind in endgame, take risks for big gains\r\n        score += move.flippedPositions.length * 4;\r\n        if (move.score.grade === Grade.A || move.score.grade === Grade.S) {\r\n          score += 10;\r\n        }\r\n        break;\r\n\r\n      case 'aggressive':\r\n        // Prioritize high-scoring moves when behind\r\n        if (move.score.grade === Grade.A || move.score.grade === Grade.S) {\r\n          score += 8;\r\n        }\r\n        score += move.flippedPositions.length * 2;\r\n        break;\r\n\r\n      case 'consolidate':\r\n        // Play safely when ahead\r\n        if ([0, 7, 56, 63].includes(move.position)) {\r\n          score += 10; // Corner bonus\r\n        }\r\n        if (AIUtils.isDangerousPosition(move.position)) {\r\n          score -= 8; // Avoid risk\r\n        }\r\n        break;\r\n\r\n      case 'careful':\r\n        // Low mobility - be extra careful\r\n        if (AIUtils.isDangerousPosition(move.position)) {\r\n          score -= 15;\r\n        }\r\n        score += AIUtils.evaluatePositionStability(gameState, move.position, player) * 2;\r\n        break;\r\n\r\n      case 'opportunistic':\r\n        // High mobility - can take some risks for rewards\r\n        if (move.score.grade === Grade.S) {\r\n          score += 15;\r\n        }\r\n        break;\r\n\r\n      case 'cautious':\r\n        // Early game caution\r\n        if (AIUtils.isDangerousPosition(move.position)) {\r\n          score -= 10;\r\n        }\r\n        break;\r\n\r\n      default: // 'balanced'\r\n        // Standard evaluation\r\n        break;\r\n    }\r\n\r\n    return score;\r\n  }\r\n\r\n  private getSelectionTemperature(strategy: string): number {\r\n    switch (strategy) {\r\n      case 'aggressive':\r\n      case 'endgame_behind':\r\n        return 1.5; // More randomization when desperate\r\n      case 'careful':\r\n      case 'consolidate':\r\n        return 3.0; // Less randomization when being careful\r\n      default:\r\n        return 2.0; // Moderate randomization\r\n    }\r\n  }\r\n\r\n  private calculateAdaptiveThinkingTime(\r\n    _gameState: GameState,\r\n    moveCount: number,\r\n    strategy: string,\r\n    timeLimit: number,\r\n  ): number {\r\n    let baseTime = 400;\r\n\r\n    // More thinking for complex situations\r\n    if (moveCount > 8) {baseTime += 200;}\r\n    if (moveCount < 3) {baseTime += 100;} // Think more when few options\r\n\r\n    // Strategy-based adjustments\r\n    switch (strategy) {\r\n      case 'endgame_ahead':\r\n      case 'endgame_behind':\r\n        baseTime += 300; // Endgame needs more thought\r\n        break;\r\n      case 'careful':\r\n        baseTime += 200; // Be more careful\r\n        break;\r\n      case 'opportunistic':\r\n        baseTime -= 100; // Can be quicker with many options\r\n        break;\r\n    }\r\n\r\n    // Add randomization\r\n    baseTime += Math.random() * 200;\r\n\r\n    return Math.min(baseTime, timeLimit * 0.9);\r\n  }\r\n\r\n  private calculateAdaptiveConfidence(strategy: string, selectedMove: any, topMoves: any[]): number {\r\n    let confidence = 0.7; // Base confidence\r\n\r\n    // Strategy-based confidence\r\n    switch (strategy) {\r\n      case 'consolidate':\r\n      case 'endgame_ahead':\r\n        confidence = 0.8; // More confident when ahead\r\n        break;\r\n      case 'aggressive':\r\n      case 'endgame_behind':\r\n        confidence = 0.6; // Less confident when taking risks\r\n        break;\r\n      case 'careful':\r\n        confidence = 0.75; // Moderate confidence in careful play\r\n        break;\r\n    }\r\n\r\n    // Adjust based on move quality\r\n    if (selectedMove.score?.grade === Grade.S) {\r\n      confidence = Math.min(0.95, confidence + 0.15);\r\n    } else if (selectedMove.score?.grade === Grade.A) {\r\n      confidence = Math.min(0.9, confidence + 0.1);\r\n    }\r\n\r\n    // Reduce confidence if many similar options\r\n    if (topMoves.length > 4) {\r\n      confidence -= 0.1;\r\n    }\r\n\r\n    return Math.max(0.2, confidence);\r\n  }\r\n}\r\n\r\n/**\r\n * Factory function to create greedy AI variants\r\n */\r\nexport const createGreedyAI = {\r\n  /**\r\n   * Standard greedy AI\r\n   */\r\n  standard(): GreedyAI {\r\n    return new GreedyAI();\r\n  },\r\n\r\n  /**\r\n   * Enhanced greedy with additional heuristics\r\n   */\r\n  enhanced(): EnhancedGreedyAI {\r\n    return new EnhancedGreedyAI();\r\n  },\r\n\r\n  /**\r\n   * Adaptive greedy that changes strategy based on game state\r\n   */\r\n  adaptive(): AdaptiveGreedyAI {\r\n    return new AdaptiveGreedyAI();\r\n  },\r\n};","/**\r\n * Advanced Position Evaluation System\r\n *\r\n * Sophisticated evaluation function for Minimax AI that considers:\r\n * - Position value and stability\r\n * - Mobility and potential moves\r\n * - Corner and edge control\r\n * - Game phase awareness\r\n * - Parity and timing\r\n */\r\n\r\nimport {\r\n  BoardPosition,\r\n  PlayerColor,\r\n  positionToCoords,\r\n  isCorner,\r\n  isEdge,\r\n  isXSquare,\r\n  isCSquare,\r\n  BOARD_SIZE,\r\n} from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\n\r\n/**\r\n * Comprehensive position evaluation weights\r\n */\r\nconst EVALUATION_WEIGHTS = {\r\n  POSITION_VALUE: 1.0,\r\n  MOBILITY: 2.0,\r\n  STABILITY: 3.0,\r\n  CORNER_CONTROL: 5.0,\r\n  EDGE_CONTROL: 1.5,\r\n  POTENTIAL_MOBILITY: 1.0,\r\n  PARITY: 0.5,\r\n  ENDGAME_MATERIAL: 10.0,\r\n} as const;\r\n\r\n/**\r\n * Static position values for advanced evaluation\r\n */\r\nconst ADVANCED_POSITION_VALUES = [\r\n  100, -20,  10,   5,   5,  10, -20, 100,\r\n  -20, -50,  -2,  -2,  -2,  -2, -50, -20,\r\n   10,  -2,  16,   2,   2,  16,  -2,  10,\r\n    5,  -2,   2,   1,   1,   2,  -2,   5,\r\n    5,  -2,   2,   1,   1,   2,  -2,   5,\r\n   10,  -2,  16,   2,   2,  16,  -2,  10,\r\n  -20, -50,  -2,  -2,  -2,  -2, -50, -20,\r\n  100, -20,  10,   5,   5,  10, -20, 100,\r\n] as const;\r\n\r\n/**\r\n * Stability values for each position\r\n */\r\nconst STABILITY_VALUES = [\r\n  4, 0, 3, 2, 2, 3, 0, 4,\r\n  0, 0, 1, 1, 1, 1, 0, 0,\r\n  3, 1, 2, 1, 1, 2, 1, 3,\r\n  2, 1, 1, 1, 1, 1, 1, 2,\r\n  2, 1, 1, 1, 1, 1, 1, 2,\r\n  3, 1, 2, 1, 1, 2, 1, 3,\r\n  0, 0, 1, 1, 1, 1, 0, 0,\r\n  4, 0, 3, 2, 2, 3, 0, 4,\r\n] as const;\r\n\r\n/**\r\n * Result of position evaluation\r\n */\r\nexport interface EvaluationResult {\r\n  readonly totalScore: number;\r\n  readonly breakdown: {\r\n    readonly positionValue: number;\r\n    readonly mobility: number;\r\n    readonly stability: number;\r\n    readonly cornerControl: number;\r\n    readonly edgeControl: number;\r\n    readonly potentialMobility: number;\r\n    readonly parity: number;\r\n    readonly material: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Advanced position evaluator for AI strategies\r\n */\r\nexport class AdvancedEvaluator {\r\n  /**\r\n   * Evaluate position for a specific player\r\n   */\r\n  static evaluatePosition(gameState: GameState, player: PlayerColor): EvaluationResult {\r\n    const board = gameState.board as Uint8Array;\r\n    const opponent = player === PlayerColor.BLACK ? PlayerColor.WHITE : PlayerColor.BLACK;\r\n\r\n    // Calculate individual evaluation components\r\n    const positionValue = this.evaluatePositionValue(board, player, opponent);\r\n    const mobility = this.evaluateMobility(gameState, player, opponent);\r\n    const stability = this.evaluateStability(board, player, opponent);\r\n    const cornerControl = this.evaluateCornerControl(board, player, opponent);\r\n    const edgeControl = this.evaluateEdgeControl(board, player, opponent);\r\n    const potentialMobility = this.evaluatePotentialMobility(board, player, opponent);\r\n    const parity = this.evaluateParity(board, player, opponent);\r\n    const material = this.evaluateMaterial(board, player, opponent);\r\n\r\n    // Calculate weighted total score\r\n    const totalScore =\r\n      positionValue * EVALUATION_WEIGHTS.POSITION_VALUE +\r\n      mobility * EVALUATION_WEIGHTS.MOBILITY +\r\n      stability * EVALUATION_WEIGHTS.STABILITY +\r\n      cornerControl * EVALUATION_WEIGHTS.CORNER_CONTROL +\r\n      edgeControl * EVALUATION_WEIGHTS.EDGE_CONTROL +\r\n      potentialMobility * EVALUATION_WEIGHTS.POTENTIAL_MOBILITY +\r\n      parity * EVALUATION_WEIGHTS.PARITY +\r\n      material * EVALUATION_WEIGHTS.ENDGAME_MATERIAL;\r\n\r\n    return {\r\n      totalScore,\r\n      breakdown: {\r\n        positionValue,\r\n        mobility,\r\n        stability,\r\n        cornerControl,\r\n        edgeControl,\r\n        potentialMobility,\r\n        parity,\r\n        material,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Evaluate position values of pieces on board\r\n   */\r\n  private static evaluatePositionValue(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let score = 0;\r\n\r\n    for (let position = 0; position < 64; position++) {\r\n      const piece = board[position];\r\n      if (piece === player) {\r\n        score += ADVANCED_POSITION_VALUES[position] ?? 0;\r\n      } else if (piece === opponent) {\r\n        score -= ADVANCED_POSITION_VALUES[position] ?? 0;\r\n      }\r\n    }\r\n\r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Evaluate current mobility (number of valid moves)\r\n   */\r\n  private static evaluateMobility(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    const playerMobility = gameState.currentPlayer === player ? gameState.validMoves.size : 0;\r\n    const opponentMobility = gameState.currentPlayer === opponent ? gameState.validMoves.size : 0;\r\n\r\n    // More mobility is better, but avoid division by zero\r\n    if (playerMobility + opponentMobility === 0) return 0;\r\n\r\n    return ((playerMobility - opponentMobility) / (playerMobility + opponentMobility)) * 100;\r\n  }\r\n\r\n  /**\r\n   * Evaluate stability of pieces (how hard they are to flip)\r\n   */\r\n  private static evaluateStability(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let playerStability = 0;\r\n    let opponentStability = 0;\r\n\r\n    for (let position = 0; position < 64; position++) {\r\n      const piece = board[position];\r\n      const stabilityValue = this.calculatePieceStability(board, position);\r\n\r\n      if (piece === player) {\r\n        playerStability += stabilityValue;\r\n      } else if (piece === opponent) {\r\n        opponentStability += stabilityValue;\r\n      }\r\n    }\r\n\r\n    return playerStability - opponentStability;\r\n  }\r\n\r\n  /**\r\n   * Calculate stability of a single piece\r\n   */\r\n  private static calculatePieceStability(board: Uint8Array, position: BoardPosition): number {\r\n    const piece = board[position];\r\n    if (piece === PlayerColor.EMPTY || piece === undefined) return 0;\r\n\r\n    let stability = STABILITY_VALUES[position] ?? 0;\r\n\r\n    // Corner pieces are completely stable\r\n    if (isCorner(position)) {\r\n      return stability + 10;\r\n    }\r\n\r\n    // Check stability in all 8 directions\r\n    const directions = [-9, -8, -7, -1, 1, 7, 8, 9];\r\n    let stableDirections = 0;\r\n\r\n    for (const dir of directions) {\r\n      if (this.isDirectionStable(board, position, dir, piece)) {\r\n        stableDirections++;\r\n      }\r\n    }\r\n\r\n    return stability + stableDirections;\r\n  }\r\n\r\n  /**\r\n   * Check if a piece is stable in a specific direction\r\n   */\r\n  private static isDirectionStable(\r\n    board: Uint8Array,\r\n    position: BoardPosition,\r\n    direction: number,\r\n    piece: PlayerColor,\r\n  ): boolean {\r\n    const pos1 = position + direction;\r\n    const pos2 = position - direction;\r\n\r\n    // Check bounds\r\n    if (pos1 < 0 || pos1 >= 64 || pos2 < 0 || pos2 >= 64) return true;\r\n\r\n    // Both directions should have same color or edge\r\n    return board[pos1] === piece || board[pos2] === piece;\r\n  }\r\n\r\n  /**\r\n   * Evaluate corner control\r\n   */\r\n  private static evaluateCornerControl(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    const corners = [0, 7, 56, 63];\r\n    let playerCorners = 0;\r\n    let opponentCorners = 0;\r\n\r\n    for (const corner of corners) {\r\n      if (board[corner] === player) {\r\n        playerCorners++;\r\n      } else if (board[corner] === opponent) {\r\n        opponentCorners++;\r\n      }\r\n    }\r\n\r\n    return (playerCorners - opponentCorners) * 25;\r\n  }\r\n\r\n  /**\r\n   * Evaluate edge control\r\n   */\r\n  private static evaluateEdgeControl(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let playerEdges = 0;\r\n    let opponentEdges = 0;\r\n\r\n    for (let position = 0; position < 64; position++) {\r\n      if (isEdge(position) && !isCorner(position)) {\r\n        if (board[position] === player) {\r\n          playerEdges++;\r\n        } else if (board[position] === opponent) {\r\n          opponentEdges++;\r\n        }\r\n      }\r\n    }\r\n\r\n    return playerEdges - opponentEdges;\r\n  }\r\n\r\n  /**\r\n   * Evaluate potential mobility (empty squares adjacent to opponent pieces)\r\n   */\r\n  private static evaluatePotentialMobility(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let playerPotential = 0;\r\n    let opponentPotential = 0;\r\n\r\n    for (let position = 0; position < 64; position++) {\r\n      if (board[position] === PlayerColor.EMPTY) {\r\n        const adjacentToPlayer = this.isAdjacentToColor(board, position, player);\r\n        const adjacentToOpponent = this.isAdjacentToColor(board, position, opponent);\r\n\r\n        if (adjacentToPlayer) playerPotential++;\r\n        if (adjacentToOpponent) opponentPotential++;\r\n      }\r\n    }\r\n\r\n    return playerPotential - opponentPotential;\r\n  }\r\n\r\n  /**\r\n   * Check if a position is adjacent to pieces of a specific color\r\n   */\r\n  private static isAdjacentToColor(\r\n    board: Uint8Array,\r\n    position: BoardPosition,\r\n    color: PlayerColor,\r\n  ): boolean {\r\n    const directions = [-9, -8, -7, -1, 1, 7, 8, 9];\r\n\r\n    for (const dir of directions) {\r\n      const adjacent = position + dir;\r\n      if (adjacent >= 0 && adjacent < 64 && board[adjacent] === color) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Evaluate parity (who gets the last move)\r\n   */\r\n  private static evaluateParity(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let emptySquares = 0;\r\n\r\n    for (let i = 0; i < 64; i++) {\r\n      if (board[i] === PlayerColor.EMPTY) {\r\n        emptySquares++;\r\n      }\r\n    }\r\n\r\n    // If odd number of empty squares, current player has advantage\r\n    return emptySquares % 2 === 1 ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * Evaluate material balance (piece count) - important in endgame\r\n   */\r\n  private static evaluateMaterial(\r\n    board: Uint8Array,\r\n    player: PlayerColor,\r\n    opponent: PlayerColor,\r\n  ): number {\r\n    let playerPieces = 0;\r\n    let opponentPieces = 0;\r\n    let emptySquares = 0;\r\n\r\n    for (let i = 0; i < 64; i++) {\r\n      const piece = board[i];\r\n      if (piece === player) {\r\n        playerPieces++;\r\n      } else if (piece === opponent) {\r\n        opponentPieces++;\r\n      } else {\r\n        emptySquares++;\r\n      }\r\n    }\r\n\r\n    // Material evaluation is more important in endgame\r\n    const endgameWeight = emptySquares < 16 ? 2.0 : 0.1;\r\n\r\n    return (playerPieces - opponentPieces) * endgameWeight;\r\n  }\r\n\r\n  /**\r\n   * Quick evaluation for move ordering (faster version)\r\n   */\r\n  static quickEvaluate(\r\n    board: Uint8Array,\r\n    position: BoardPosition,\r\n    player: PlayerColor,\r\n    flippedPositions: BoardPosition[],\r\n  ): number {\r\n    let score = 0;\r\n\r\n    // Position value\r\n    score += ADVANCED_POSITION_VALUES[position] ?? 0;\r\n\r\n    // Flipped pieces count\r\n    score += flippedPositions.length * 5;\r\n\r\n    // Corner bonus\r\n    if (isCorner(position)) {\r\n      score += 50;\r\n    }\r\n\r\n    // Avoid X-squares early\r\n    if (isXSquare(position)) {\r\n      score -= 25;\r\n    }\r\n\r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Game phase detection\r\n   */\r\n  static getGamePhase(board: Uint8Array): 'opening' | 'midgame' | 'endgame' {\r\n    let emptySquares = 0;\r\n\r\n    for (let i = 0; i < 64; i++) {\r\n      if (board[i] === PlayerColor.EMPTY) {\r\n        emptySquares++;\r\n      }\r\n    }\r\n\r\n    if (emptySquares > 40) return 'opening';\r\n    if (emptySquares > 16) return 'midgame';\r\n    return 'endgame';\r\n  }\r\n}\r\n\r\n/**\r\n * Export convenience functions\r\n */\r\nexport const evaluatePosition = AdvancedEvaluator.evaluatePosition;\r\nexport const quickEvaluate = AdvancedEvaluator.quickEvaluate;\r\nexport const getGamePhase = AdvancedEvaluator.getGamePhase;","/**\r\n * Game State Simulator\r\n *\r\n * Provides efficient game state simulation for AI search algorithms.\r\n * Creates new game states without modifying the original for minimax search.\r\n */\r\n\r\nimport { PlayerColor, BoardPosition, BOARD_SIZE, GameStatus } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\nimport { getValidMoves } from '@/core/utils/move-validator';\r\n\r\n/**\r\n * Simulated game state for AI search\r\n */\r\nexport interface SimulatedGameState {\r\n  readonly board: Uint8Array;\r\n  readonly currentPlayer: PlayerColor;\r\n  readonly validMoves: Map<BoardPosition, readonly BoardPosition[]>;\r\n  readonly scores: {\r\n    readonly black: number;\r\n    readonly white: number;\r\n  };\r\n  readonly gameOver: boolean;\r\n  readonly consecutivePasses: number;\r\n}\r\n\r\n/**\r\n * Game state simulator for AI algorithms\r\n */\r\nexport class GameSimulator {\r\n  /**\r\n   * Convert a GameState to SimulatedGameState\r\n   */\r\n  static fromGameState(gameState: GameState): SimulatedGameState {\r\n    // Check if game is over based on game status\r\n    const gameOver = gameState.gameStatus === GameStatus.GAME_OVER ||\r\n                     (gameState as any).gameOver === true ||\r\n                     gameState.validMoves.size === 0;\r\n\r\n    return {\r\n      board: new Uint8Array(gameState.board),\r\n      currentPlayer: gameState.currentPlayer,\r\n      validMoves: new Map(gameState.validMoves),\r\n      scores: { ...gameState.scores },\r\n      gameOver,\r\n      consecutivePasses: (gameState as any).consecutivePasses || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Make a move and return new simulated game state\r\n   */\r\n  static makeMove(\r\n    state: SimulatedGameState,\r\n    position: BoardPosition,\r\n  ): SimulatedGameState | null {\r\n    // Validate move\r\n    const flippedPositions = state.validMoves.get(position);\r\n    if (!flippedPositions) {\r\n      return null;\r\n    }\r\n\r\n    // Create new board\r\n    const newBoard = new Uint8Array(state.board);\r\n\r\n    // Place the piece\r\n    newBoard[position] = state.currentPlayer;\r\n\r\n    // Flip pieces\r\n    for (const flippedPos of flippedPositions) {\r\n      newBoard[flippedPos] = state.currentPlayer;\r\n    }\r\n\r\n    // Switch player\r\n    const nextPlayer = state.currentPlayer === PlayerColor.BLACK\r\n      ? PlayerColor.WHITE\r\n      : PlayerColor.BLACK;\r\n\r\n    // Calculate new scores\r\n    const newScores = this.calculateScores(newBoard);\r\n\r\n    // Find valid moves for next player\r\n    const nextValidMoves = getValidMoves(newBoard, nextPlayer);\r\n\r\n    // Check for consecutive passes\r\n    let newConsecutivePasses = 0;\r\n    let gameOver = false;\r\n\r\n    if (nextValidMoves.size === 0) {\r\n      // Next player has no moves, switch back\r\n      const afterPassPlayer = nextPlayer === PlayerColor.BLACK\r\n        ? PlayerColor.WHITE\r\n        : PlayerColor.BLACK;\r\n\r\n      const afterPassMoves = getValidMoves(newBoard, afterPassPlayer);\r\n\r\n      if (afterPassMoves.size === 0) {\r\n        // Game over - both players have no moves\r\n        gameOver = true;\r\n        newConsecutivePasses = 2;\r\n      } else {\r\n        // Switch back to original player\r\n        newConsecutivePasses = 1;\r\n        return {\r\n          board: newBoard,\r\n          currentPlayer: afterPassPlayer,\r\n          validMoves: afterPassMoves,\r\n          scores: newScores,\r\n          gameOver: false,\r\n          consecutivePasses: newConsecutivePasses,\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      board: newBoard,\r\n      currentPlayer: nextPlayer,\r\n      validMoves: nextValidMoves,\r\n      scores: newScores,\r\n      gameOver,\r\n      consecutivePasses: newConsecutivePasses,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Make a pass (skip turn) and return new game state\r\n   */\r\n  static makePass(state: SimulatedGameState): SimulatedGameState {\r\n    const nextPlayer = state.currentPlayer === PlayerColor.BLACK\r\n      ? PlayerColor.WHITE\r\n      : PlayerColor.BLACK;\r\n\r\n    const nextValidMoves = getValidMoves(state.board, nextPlayer);\r\n    const newConsecutivePasses = state.consecutivePasses + 1;\r\n\r\n    return {\r\n      board: state.board, // Board unchanged\r\n      currentPlayer: nextPlayer,\r\n      validMoves: nextValidMoves,\r\n      scores: state.scores, // Scores unchanged\r\n      gameOver: newConsecutivePasses >= 2 || nextValidMoves.size === 0,\r\n      consecutivePasses: newConsecutivePasses,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate scores from board state\r\n   */\r\n  private static calculateScores(board: Uint8Array): { black: number; white: number } {\r\n    let black = 0;\r\n    let white = 0;\r\n\r\n    for (let i = 0; i < board.length; i++) {\r\n      if (board[i] === PlayerColor.BLACK) {\r\n        black++;\r\n      } else if (board[i] === PlayerColor.WHITE) {\r\n        white++;\r\n      }\r\n    }\r\n\r\n    return { black, white };\r\n  }\r\n\r\n  /**\r\n   * Get all possible moves with their resulting states\r\n   */\r\n  static getAllPossibleMoves(\r\n    state: SimulatedGameState,\r\n  ): Array<{ move: BoardPosition; newState: SimulatedGameState }> {\r\n    const moves: Array<{ move: BoardPosition; newState: SimulatedGameState }> = [];\r\n\r\n    for (const move of state.validMoves.keys()) {\r\n      const newState = this.makeMove(state, move);\r\n      if (newState) {\r\n        moves.push({ move, newState });\r\n      }\r\n    }\r\n\r\n    return moves;\r\n  }\r\n\r\n  /**\r\n   * Check if game is in endgame phase\r\n   */\r\n  static isEndgame(state: SimulatedGameState): boolean {\r\n    let emptySquares = 0;\r\n    for (let i = 0; i < state.board.length; i++) {\r\n      if (state.board[i] === PlayerColor.EMPTY) {\r\n        emptySquares++;\r\n      }\r\n    }\r\n    return emptySquares <= 16;\r\n  }\r\n\r\n  /**\r\n   * Check if game is in opening phase\r\n   */\r\n  static isOpening(state: SimulatedGameState): boolean {\r\n    let occupiedSquares = 0;\r\n    for (let i = 0; i < state.board.length; i++) {\r\n      if (state.board[i] !== PlayerColor.EMPTY) {\r\n        occupiedSquares++;\r\n      }\r\n    }\r\n    return occupiedSquares <= 12; // First 8 moves after initial setup\r\n  }\r\n\r\n  /**\r\n   * Get game phase as a ratio (0 = start, 1 = end)\r\n   */\r\n  static getGamePhaseRatio(state: SimulatedGameState): number {\r\n    let occupiedSquares = 0;\r\n    for (let i = 0; i < state.board.length; i++) {\r\n      if (state.board[i] !== PlayerColor.EMPTY) {\r\n        occupiedSquares++;\r\n      }\r\n    }\r\n    return Math.min(1.0, (occupiedSquares - 4) / 60); // Start counting after initial 4 pieces\r\n  }\r\n\r\n  /**\r\n   * Generate a hash key for the game state (for transposition tables)\r\n   */\r\n  static getStateHash(state: SimulatedGameState): string {\r\n    // Create a hash based on board state and current player\r\n    const boardHash = Array.from(state.board).join('');\r\n    return `${boardHash}_${state.currentPlayer}_${state.consecutivePasses}`;\r\n  }\r\n\r\n  /**\r\n   * Check if two states are equivalent\r\n   */\r\n  static statesEqual(state1: SimulatedGameState, state2: SimulatedGameState): boolean {\r\n    if (state1.currentPlayer !== state2.currentPlayer) return false;\r\n    if (state1.consecutivePasses !== state2.consecutivePasses) return false;\r\n\r\n    for (let i = 0; i < state1.board.length; i++) {\r\n      if (state1.board[i] !== state2.board[i]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy a simulated game state\r\n   */\r\n  static copyState(state: SimulatedGameState): SimulatedGameState {\r\n    return {\r\n      board: new Uint8Array(state.board),\r\n      currentPlayer: state.currentPlayer,\r\n      validMoves: new Map(state.validMoves),\r\n      scores: { ...state.scores },\r\n      gameOver: state.gameOver,\r\n      consecutivePasses: state.consecutivePasses,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get detailed state information for debugging\r\n   */\r\n  static getStateInfo(state: SimulatedGameState): {\r\n    pieceCount: { black: number; white: number; empty: number };\r\n    gamePhase: 'opening' | 'midgame' | 'endgame';\r\n    mobilityCount: number;\r\n  } {\r\n    let black = 0, white = 0, empty = 0;\r\n\r\n    for (let i = 0; i < state.board.length; i++) {\r\n      switch (state.board[i]) {\r\n        case PlayerColor.BLACK: black++; break;\r\n        case PlayerColor.WHITE: white++; break;\r\n        case PlayerColor.EMPTY: empty++; break;\r\n      }\r\n    }\r\n\r\n    let gamePhase: 'opening' | 'midgame' | 'endgame';\r\n    if (empty > 40) gamePhase = 'opening';\r\n    else if (empty > 16) gamePhase = 'midgame';\r\n    else gamePhase = 'endgame';\r\n\r\n    return {\r\n      pieceCount: { black, white, empty },\r\n      gamePhase,\r\n      mobilityCount: state.validMoves.size,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate that a simulated state is consistent\r\n   */\r\n  static validateState(state: SimulatedGameState): boolean {\r\n    try {\r\n      // Check board size\r\n      if (state.board.length !== 64) return false;\r\n\r\n      // Check player colors are valid\r\n      if (state.currentPlayer !== PlayerColor.BLACK &&\r\n          state.currentPlayer !== PlayerColor.WHITE) return false;\r\n\r\n      // Check scores match board\r\n      const calculatedScores = this.calculateScores(state.board);\r\n      if (calculatedScores.black !== state.scores.black ||\r\n          calculatedScores.white !== state.scores.white) return false;\r\n\r\n      // Check valid moves are actually valid\r\n      for (const [position, flips] of state.validMoves.entries()) {\r\n        if (position < 0 || position >= 64) return false;\r\n        if (state.board[position] !== PlayerColor.EMPTY) return false;\r\n        // Additional validation could check if flips are correct\r\n      }\r\n\r\n      return true;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Export convenience functions\r\n */\r\nexport const fromGameState = GameSimulator.fromGameState;\r\nexport const makeMove = GameSimulator.makeMove;\r\nexport const makePass = GameSimulator.makePass;\r\nexport const getAllPossibleMoves = GameSimulator.getAllPossibleMoves;","/**\r\n * Minimax AI Strategy with Alpha-Beta Pruning\r\n *\r\n * Advanced AI implementation using minimax algorithm with:\r\n * - Alpha-beta pruning for performance optimization\r\n * - Iterative deepening for time management\r\n * - Move ordering for better pruning\r\n * - Transposition table for cached results\r\n * - Configurable search depth and time limits\r\n */\r\n\r\nimport { AIDifficulty, PlayerColor, BoardPosition } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\nimport { AIStrategyBase, type AIMoveResult, AIUtils } from '../ai-strategy-base';\r\nimport { evaluateAllMoves } from '@/core/utils/move-evaluator';\r\nimport { AdvancedEvaluator, quickEvaluate } from './evaluation';\r\nimport { GameSimulator, type SimulatedGameState } from '../game-simulator';\r\n\r\n/**\r\n * Minimax AI configuration\r\n */\r\nexport interface MinimaxConfig {\r\n  maxDepth: number;\r\n  maxTime: number;\r\n  useIterativeDeepening: boolean;\r\n  useTranspositionTable: boolean;\r\n  useMoveOrdering: boolean;\r\n  aspirationWindow?: number;\r\n}\r\n\r\n/**\r\n * Transposition table entry\r\n */\r\ninterface TranspositionEntry {\r\n  depth: number;\r\n  score: number;\r\n  flag: 'exact' | 'lower' | 'upper';\r\n  bestMove?: BoardPosition;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * Search result from minimax\r\n */\r\ninterface SearchResult {\r\n  score: number;\r\n  bestMove: BoardPosition;\r\n  depth: number;\r\n  nodesEvaluated: number;\r\n  timeElapsed: number;\r\n  terminated: boolean;\r\n}\r\n\r\n/**\r\n * Minimax AI Strategy Implementation\r\n */\r\nexport class MinimaxAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.MINIMAX;\r\n  public readonly name = 'Minimax AI';\r\n  public readonly description = 'Advanced AI using minimax with alpha-beta pruning';\r\n\r\n  private _config: MinimaxConfig;\r\n  private _transpositionTable = new Map<string, TranspositionEntry>();\r\n  private _killerMoves: BoardPosition[][] = [];\r\n  private _historyTable = new Map<string, number>();\r\n  private _nodesEvaluated = 0;\r\n  private _startTime = 0;\r\n\r\n  constructor(config: Partial<MinimaxConfig> = {}) {\r\n    super();\r\n    this._config = {\r\n      maxDepth: 6,\r\n      maxTime: 3000,\r\n      useIterativeDeepening: true,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      aspirationWindow: 50,\r\n      ...config,\r\n    };\r\n\r\n    // Initialize killer moves table\r\n    for (let depth = 0; depth <= this._config.maxDepth; depth++) {\r\n      this._killerMoves[depth] = [];\r\n    }\r\n  }\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    this._startTime = Date.now();\r\n    this._nodesEvaluated = 0;\r\n    const effectiveTimeLimit = Math.min(timeLimit, this._config.maxTime);\r\n\r\n    const validMoves = Array.from(gameState.validMoves.keys());\r\n\r\n    if (validMoves.length === 0) {\r\n      throw new Error('No valid moves available');\r\n    }\r\n\r\n    if (validMoves.length === 1) {\r\n      // Only one move available\r\n      return {\r\n        position: validMoves[0]!,\r\n        confidence: 1.0,\r\n        evaluation: 0,\r\n        thinkingTime: Date.now() - this._startTime,\r\n        depth: 0,\r\n        nodesEvaluated: 1,\r\n      };\r\n    }\r\n\r\n    let searchResult: SearchResult;\r\n\r\n    if (this._config.useIterativeDeepening) {\r\n      searchResult = await this.iterativeDeepening(gameState, player, effectiveTimeLimit);\r\n    } else {\r\n      searchResult = await this.search(gameState, player, this._config.maxDepth, effectiveTimeLimit);\r\n    }\r\n\r\n    const confidence = this.calculateConfidence(searchResult, validMoves.length);\r\n\r\n    return {\r\n      position: searchResult.bestMove,\r\n      confidence,\r\n      evaluation: searchResult.score,\r\n      thinkingTime: searchResult.timeElapsed,\r\n      depth: searchResult.depth,\r\n      nodesEvaluated: searchResult.nodesEvaluated,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Iterative deepening search\r\n   */\r\n  private async iterativeDeepening(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<SearchResult> {\r\n    let bestResult: SearchResult = {\r\n      score: -Infinity,\r\n      bestMove: Array.from(gameState.validMoves.keys())[0]!,\r\n      depth: 1,\r\n      nodesEvaluated: 0,\r\n      timeElapsed: 0,\r\n      terminated: false,\r\n    };\r\n\r\n    let lastScore = 0;\r\n    let aspirationAlpha = -Infinity;\r\n    let aspirationBeta = Infinity;\r\n\r\n    for (let depth = 1; depth <= this._config.maxDepth; depth++) {\r\n      const depthStartTime = Date.now();\r\n\r\n      // Check time limit\r\n      if (Date.now() - this._startTime >= timeLimit * 0.9) {\r\n        break;\r\n      }\r\n\r\n      // Set aspiration window if available and enabled\r\n      if (this._config.aspirationWindow && depth > 2) {\r\n        aspirationAlpha = lastScore - this._config.aspirationWindow;\r\n        aspirationBeta = lastScore + this._config.aspirationWindow;\r\n      }\r\n\r\n      try {\r\n        const result = await this.minimaxSearch(\r\n          gameState,\r\n          depth,\r\n          aspirationAlpha,\r\n          aspirationBeta,\r\n          true,\r\n          player,\r\n          timeLimit,\r\n        );\r\n\r\n        // If search completed successfully, update best result\r\n        if (result.score > -Infinity) {\r\n          bestResult = {\r\n            score: result.score,\r\n            bestMove: result.bestMove!,\r\n            depth,\r\n            nodesEvaluated: this._nodesEvaluated,\r\n            timeElapsed: Date.now() - this._startTime,\r\n            terminated: false,\r\n          };\r\n          lastScore = result.score;\r\n        }\r\n\r\n        // Research with wider window if aspiration search failed\r\n        if (this._config.aspirationWindow &&\r\n            (result.score <= aspirationAlpha || result.score >= aspirationBeta)) {\r\n          const widerResult = await this.minimaxSearch(\r\n            gameState,\r\n            depth,\r\n            -Infinity,\r\n            Infinity,\r\n            true,\r\n            player,\r\n            timeLimit,\r\n          );\r\n\r\n          if (widerResult.score > -Infinity) {\r\n            bestResult = {\r\n              score: widerResult.score,\r\n              bestMove: widerResult.bestMove!,\r\n              depth,\r\n              nodesEvaluated: this._nodesEvaluated,\r\n              timeElapsed: Date.now() - this._startTime,\r\n              terminated: false,\r\n            };\r\n          }\r\n        }\r\n\r\n      } catch (error) {\r\n        // Time limit reached, return best result so far\r\n        break;\r\n      }\r\n\r\n      // Early termination for quick wins/losses\r\n      if (Math.abs(bestResult.score) > 1000) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return bestResult;\r\n  }\r\n\r\n  /**\r\n   * Single depth search\r\n   */\r\n  private async search(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    depth: number,\r\n    timeLimit: number,\r\n  ): Promise<SearchResult> {\r\n    const result = await this.minimaxSearch(\r\n      gameState,\r\n      depth,\r\n      -Infinity,\r\n      Infinity,\r\n      true,\r\n      player,\r\n      timeLimit,\r\n    );\r\n\r\n    return {\r\n      score: result.score,\r\n      bestMove: result.bestMove!,\r\n      depth,\r\n      nodesEvaluated: this._nodesEvaluated,\r\n      timeElapsed: Date.now() - this._startTime,\r\n      terminated: result.score === -Infinity,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Minimax search with alpha-beta pruning\r\n   */\r\n  private async minimaxSearch(\r\n    gameState: GameState | SimulatedGameState,\r\n    depth: number,\r\n    alpha: number,\r\n    beta: number,\r\n    isMaximizing: boolean,\r\n    originalPlayer: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<{ score: number; bestMove?: BoardPosition }> {\r\n    this._nodesEvaluated++;\r\n\r\n    // Check time limit\r\n    if (Date.now() - this._startTime >= timeLimit) {\r\n      return { score: -Infinity };\r\n    }\r\n\r\n    // Check transposition table\r\n    if (this._config.useTranspositionTable) {\r\n      const ttEntry = this.lookupTransposition(gameState, depth);\r\n      if (ttEntry) {\r\n        if (ttEntry.flag === 'exact') {\r\n          return { score: ttEntry.score, bestMove: ttEntry.bestMove };\r\n        } else if (ttEntry.flag === 'lower' && ttEntry.score >= beta) {\r\n          return { score: ttEntry.score, bestMove: ttEntry.bestMove };\r\n        } else if (ttEntry.flag === 'upper' && ttEntry.score <= alpha) {\r\n          return { score: ttEntry.score, bestMove: ttEntry.bestMove };\r\n        }\r\n      }\r\n    }\r\n\r\n    // Terminal node evaluation\r\n    if (depth === 0 || gameState.validMoves.size === 0) {\r\n      // Convert to simulated state if needed for evaluation\r\n      const simState = 'board' in gameState && 'scores' in gameState && 'currentPlayer' in gameState\r\n        ? gameState as SimulatedGameState\r\n        : GameSimulator.fromGameState(gameState as GameState);\r\n\r\n      // Create a GameState-like object for the evaluator\r\n      const evalState = {\r\n        board: simState.board,\r\n        currentPlayer: simState.currentPlayer,\r\n        validMoves: simState.validMoves,\r\n        scores: simState.scores,\r\n        gameOver: simState.gameOver,\r\n      } as unknown as GameState;\r\n\r\n      const evaluation = AdvancedEvaluator.evaluatePosition(evalState, originalPlayer);\r\n      return { score: evaluation.totalScore };\r\n    }\r\n\r\n    // Get and order moves\r\n    const moves = this.getOrderedMoves(gameState, depth, originalPlayer);\r\n    let bestMove: BoardPosition | undefined;\r\n    let bestScore = isMaximizing ? -Infinity : Infinity;\r\n\r\n    for (const move of moves) {\r\n      // Make the move\r\n      const newGameState = this.makeMove(gameState, move);\r\n\r\n      if (!newGameState) continue;\r\n\r\n      // Recursive search\r\n      const result = await this.minimaxSearch(\r\n        newGameState,\r\n        depth - 1,\r\n        alpha,\r\n        beta,\r\n        !isMaximizing,\r\n        originalPlayer,\r\n        timeLimit,\r\n      );\r\n\r\n      // Update best score and move\r\n      if (isMaximizing) {\r\n        if (result.score > bestScore) {\r\n          bestScore = result.score;\r\n          bestMove = move;\r\n        }\r\n        alpha = Math.max(alpha, bestScore);\r\n      } else {\r\n        if (result.score < bestScore) {\r\n          bestScore = result.score;\r\n          bestMove = move;\r\n        }\r\n        beta = Math.min(beta, bestScore);\r\n      }\r\n\r\n      // Alpha-beta pruning\r\n      if (beta <= alpha) {\r\n        // Update killer moves\r\n        this.updateKillerMoves(move, depth);\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Store in transposition table\r\n    if (this._config.useTranspositionTable) {\r\n      this.storeTransposition(gameState, depth, bestScore, bestMove, alpha, beta);\r\n    }\r\n\r\n    return { score: bestScore, bestMove };\r\n  }\r\n\r\n  /**\r\n   * Get ordered moves for better alpha-beta pruning\r\n   */\r\n  private getOrderedMoves(\r\n    gameState: GameState | SimulatedGameState,\r\n    depth: number,\r\n    player: PlayerColor,\r\n  ): BoardPosition[] {\r\n    const validMoves = Array.from(gameState.validMoves.keys());\r\n\r\n    if (!this._config.useMoveOrdering) {\r\n      return validMoves;\r\n    }\r\n\r\n    // Evaluate moves for ordering\r\n    const evaluatedMoves = validMoves.map(move => {\r\n      const flippedPositions = gameState.validMoves.get(move) || [];\r\n      const score = quickEvaluate(gameState.board as Uint8Array, move, player, [...flippedPositions]);\r\n\r\n      // Bonus for killer moves\r\n      let bonus = 0;\r\n      if (this._killerMoves[depth] && this._killerMoves[depth].includes(move)) {\r\n        bonus += 1000;\r\n      }\r\n\r\n      // History table bonus\r\n      const historyKey = `${move}_${player}`;\r\n      const historyScore = this._historyTable.get(historyKey) || 0;\r\n      bonus += historyScore;\r\n\r\n      return { move, score: score + bonus };\r\n    });\r\n\r\n    // Sort by score descending (best moves first)\r\n    evaluatedMoves.sort((a, b) => b.score - a.score);\r\n\r\n    return evaluatedMoves.map(item => item.move);\r\n  }\r\n\r\n  /**\r\n   * Make a move and return new game state\r\n   */\r\n  private makeMove(gameState: GameState | SimulatedGameState, move: BoardPosition): SimulatedGameState | null {\r\n    const simState = 'board' in gameState && 'validMoves' in gameState && 'currentPlayer' in gameState\r\n      ? gameState as SimulatedGameState\r\n      : GameSimulator.fromGameState(gameState as GameState);\r\n\r\n    return GameSimulator.makeMove(simState, move);\r\n  }\r\n\r\n  /**\r\n   * Update killer moves heuristic\r\n   */\r\n  private updateKillerMoves(move: BoardPosition, depth: number): void {\r\n    if (!this._killerMoves[depth]) {\r\n      this._killerMoves[depth] = [];\r\n    }\r\n\r\n    const killers = this._killerMoves[depth];\r\n    if (!killers.includes(move)) {\r\n      killers.unshift(move);\r\n      // Keep only top 2 killer moves per depth\r\n      if (killers.length > 2) {\r\n        killers.pop();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lookup transposition table\r\n   */\r\n  private lookupTransposition(gameState: GameState | SimulatedGameState, depth: number): TranspositionEntry | null {\r\n    const key = this.getTranspositionKey(gameState);\r\n    const entry = this._transpositionTable.get(key);\r\n\r\n    if (entry && entry.depth >= depth) {\r\n      return entry;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Store result in transposition table\r\n   */\r\n  private storeTransposition(\r\n    gameState: GameState | SimulatedGameState,\r\n    depth: number,\r\n    score: number,\r\n    bestMove: BoardPosition | undefined,\r\n    alpha: number,\r\n    beta: number,\r\n  ): void {\r\n    const key = this.getTranspositionKey(gameState);\r\n\r\n    let flag: 'exact' | 'lower' | 'upper';\r\n    if (score <= alpha) {\r\n      flag = 'upper';\r\n    } else if (score >= beta) {\r\n      flag = 'lower';\r\n    } else {\r\n      flag = 'exact';\r\n    }\r\n\r\n    this._transpositionTable.set(key, {\r\n      depth,\r\n      score,\r\n      flag,\r\n      bestMove,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    // Limit table size\r\n    if (this._transpositionTable.size > 100000) {\r\n      this.cleanupTranspositionTable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate transposition table key\r\n   */\r\n  private getTranspositionKey(gameState: GameState | SimulatedGameState): string {\r\n    // Simple hash based on board state and current player\r\n    return `${Array.from(gameState.board).join('')}_${gameState.currentPlayer}`;\r\n  }\r\n\r\n  /**\r\n   * Cleanup old transposition table entries\r\n   */\r\n  private cleanupTranspositionTable(): void {\r\n    const now = Date.now();\r\n    const cutoff = now - 300000; // 5 minutes\r\n\r\n    for (const [key, entry] of this._transpositionTable.entries()) {\r\n      if (entry.timestamp < cutoff) {\r\n        this._transpositionTable.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence based on search result\r\n   */\r\n  private calculateConfidence(result: SearchResult, moveCount: number): number {\r\n    let confidence = 0.7; // Base confidence\r\n\r\n    // Higher confidence for deeper searches\r\n    confidence += Math.min(result.depth / 10, 0.2);\r\n\r\n    // Lower confidence if search was terminated early\r\n    if (result.terminated) {\r\n      confidence -= 0.3;\r\n    }\r\n\r\n    // Higher confidence for clear wins/losses\r\n    if (Math.abs(result.score) > 500) {\r\n      confidence += 0.2;\r\n    }\r\n\r\n    // Lower confidence with many moves available\r\n    if (moveCount > 8) {\r\n      confidence -= 0.1;\r\n    }\r\n\r\n    return Math.max(0.1, Math.min(0.95, confidence));\r\n  }\r\n\r\n  /**\r\n   * Get configuration\r\n   */\r\n  getConfig(): MinimaxConfig {\r\n    return { ...this._config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  setConfig(config: Partial<MinimaxConfig>): void {\r\n    this._config = { ...this._config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Clear caches\r\n   */\r\n  clearCaches(): void {\r\n    this._transpositionTable.clear();\r\n    this._historyTable.clear();\r\n    for (let depth = 0; depth <= this._config.maxDepth; depth++) {\r\n      this._killerMoves[depth] = [];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Factory functions for creating minimax AI variants\r\n */\r\nexport const createMinimaxAI = {\r\n  /**\r\n   * Basic minimax with moderate depth\r\n   */\r\n  basic(): MinimaxAI {\r\n    return new MinimaxAI({\r\n      maxDepth: 4,\r\n      maxTime: 2000,\r\n      useIterativeDeepening: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Intermediate minimax with more depth\r\n   */\r\n  intermediate(): MinimaxAI {\r\n    return new MinimaxAI({\r\n      maxDepth: 6,\r\n      maxTime: 3000,\r\n      useIterativeDeepening: true,\r\n      useTranspositionTable: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Advanced minimax with full features\r\n   */\r\n  advanced(): MinimaxAI {\r\n    return new MinimaxAI({\r\n      maxDepth: 8,\r\n      maxTime: 5000,\r\n      useIterativeDeepening: true,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      aspirationWindow: 50,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Custom minimax configuration\r\n   */\r\n  custom(config: Partial<MinimaxConfig>): MinimaxAI {\r\n    return new MinimaxAI(config);\r\n  },\r\n};","/**\r\n * Opening Book System\r\n *\r\n * Stores and retrieves optimal opening moves for Reversi/Othello.\r\n * Contains theory-based opening sequences and proven lines.\r\n */\r\n\r\nimport { BoardPosition, PlayerColor } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\n\r\n/**\r\n * Opening book entry\r\n */\r\nexport interface OpeningEntry {\r\n  readonly position: BoardPosition;\r\n  readonly score: number;        // Theoretical evaluation\r\n  readonly frequency: number;    // How often this move is played\r\n  readonly winRate: number;      // Success rate (0-1)\r\n  readonly depth: number;        // How deep into the opening this is\r\n  readonly comment?: string;     // Human-readable description\r\n  readonly variations?: OpeningEntry[]; // Follow-up moves\r\n}\r\n\r\n/**\r\n * Opening book key (board position hash)\r\n */\r\ntype OpeningKey = string;\r\n\r\n/**\r\n * Named opening sequence\r\n */\r\nexport interface OpeningSequence {\r\n  readonly name: string;\r\n  readonly description: string;\r\n  readonly moves: BoardPosition[];\r\n  readonly evaluation: number;\r\n  readonly isMainLine: boolean;\r\n}\r\n\r\n/**\r\n * Opening Book Database\r\n */\r\nexport class OpeningBook {\r\n  private readonly _entries = new Map<OpeningKey, OpeningEntry[]>();\r\n  private readonly _sequences: OpeningSequence[] = [];\r\n  private readonly _maxDepth: number;\r\n\r\n  constructor(maxDepth = 12) {\r\n    this._maxDepth = maxDepth;\r\n    this.initializeOpeningDatabase();\r\n  }\r\n\r\n  /**\r\n   * Get the best move from opening book\r\n   */\r\n  getOpeningMove(gameState: GameState): BoardPosition | null {\r\n    const key = this.generateKey(gameState);\r\n    const entries = this._entries.get(key);\r\n\r\n    if (!entries || entries.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Filter valid moves\r\n    const validEntries = entries.filter(entry =>\r\n      gameState.validMoves.has(entry.position)\r\n    );\r\n\r\n    if (validEntries.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Select best move based on score and win rate\r\n    const bestEntry = validEntries.reduce((best, current) => {\r\n      const bestValue = best.score * 0.7 + best.winRate * 0.3;\r\n      const currentValue = current.score * 0.7 + current.winRate * 0.3;\r\n      return currentValue > bestValue ? current : best;\r\n    });\r\n\r\n    return bestEntry.position;\r\n  }\r\n\r\n  /**\r\n   * Get all opening moves with scores\r\n   */\r\n  getOpeningMoves(gameState: GameState): OpeningEntry[] {\r\n    const key = this.generateKey(gameState);\r\n    const entries = this._entries.get(key) || [];\r\n\r\n    return entries.filter(entry =>\r\n      gameState.validMoves.has(entry.position)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if position is in opening book\r\n   */\r\n  hasOpeningMove(gameState: GameState): boolean {\r\n    const key = this.generateKey(gameState);\r\n    const entries = this._entries.get(key);\r\n    return entries ? entries.some(entry => gameState.validMoves.has(entry.position)) : false;\r\n  }\r\n\r\n  /**\r\n   * Get opening depth (how many moves into theory we are)\r\n   */\r\n  getOpeningDepth(gameState: GameState): number {\r\n    let depth = 0;\r\n    const totalPieces = gameState.scores.black + gameState.scores.white;\r\n    const moveCount = totalPieces - 4; // Subtract initial 4 pieces\r\n\r\n    return Math.min(moveCount, this._maxDepth);\r\n  }\r\n\r\n  /**\r\n   * Get opening sequence by name\r\n   */\r\n  getSequence(name: string): OpeningSequence | null {\r\n    return this._sequences.find(seq => seq.name === name) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all available sequences\r\n   */\r\n  getAllSequences(): OpeningSequence[] {\r\n    return [...this._sequences];\r\n  }\r\n\r\n  /**\r\n   * Initialize the opening database with known theory\r\n   */\r\n  private initializeOpeningDatabase(): void {\r\n    // Standard starting position: Black plays first after initial setup\r\n    // Initial board: center 4 squares occupied, Black to move\r\n\r\n    // Move 1: Black's first move options\r\n    this.addOpening('eeeeeeeeeeeeeeeeeeeeeeeeeeee12212100eeeeeeeeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 19, score: 0, freq: 0.3, win: 0.52, comment: 'Tiger' },      // d3\r\n      { pos: 26, score: 0, freq: 0.25, win: 0.51, comment: 'Rabbit' },    // c4\r\n      { pos: 37, score: 0, freq: 0.25, win: 0.51, comment: 'Cat' },       // f5\r\n      { pos: 44, score: 0, freq: 0.2, win: 0.50, comment: 'Ox' },         // e6\r\n    ]);\r\n\r\n    // Tiger opening (d3): Most aggressive\r\n    this.addOpening('eeeeeeeeeeeeeeeeeeee1eeeeee12111100eeeeeeeeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 18, score: 2, freq: 0.4, win: 0.53, comment: 'Tiger main line' }, // c3\r\n      { pos: 20, score: 0, freq: 0.3, win: 0.52, comment: 'Tiger solid' },     // e3\r\n      { pos: 11, score: -1, freq: 0.2, win: 0.49, comment: 'Tiger passive' },  // d2\r\n      { pos: 34, score: 1, freq: 0.1, win: 0.51, comment: 'Tiger counter' },   // c5\r\n    ]);\r\n\r\n    // Rabbit opening (c4): Balanced\r\n    this.addOpening('eeeeeeeeeeeeeeeeeeeeeeeeeeee11112100eeeeeeeeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 18, score: 1, freq: 0.35, win: 0.52, comment: 'Rabbit main' },    // c3\r\n      { pos: 19, score: 1, freq: 0.35, win: 0.52, comment: 'Rabbit parallel' }, // d3\r\n      { pos: 25, score: 0, freq: 0.2, win: 0.50, comment: 'Rabbit edge' },     // b4\r\n      { pos: 33, score: -1, freq: 0.1, win: 0.48, comment: 'Rabbit weak' },    // b5\r\n    ]);\r\n\r\n    // Cat opening (f5): Solid\r\n    this.addOpening('eeeeeeeeeeeeeeeeeeeeeeeeeeee12211100eeeee1eeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 45, score: 2, freq: 0.4, win: 0.54, comment: 'Cat main line' },   // f6\r\n      { pos: 43, score: 1, freq: 0.3, win: 0.52, comment: 'Cat solid' },       // d6\r\n      { pos: 29, score: 0, freq: 0.2, win: 0.50, comment: 'Cat transpose' },   // f4\r\n      { pos: 52, score: -1, freq: 0.1, win: 0.48, comment: 'Cat edge' },       // e7\r\n    ]);\r\n\r\n    // Ox opening (e6): Defensive\r\n    this.addOpening('eeeeeeeeeeeeeeeeeeeeeeeeeeee12211100eeeeeeeeeeee1eeeeeeeeeeeeeee', [\r\n      { pos: 43, score: 1, freq: 0.4, win: 0.52, comment: 'Ox main' },         // d6\r\n      { pos: 45, score: 1, freq: 0.3, win: 0.52, comment: 'Ox symmetric' },    // f6\r\n      { pos: 37, score: 0, freq: 0.2, win: 0.50, comment: 'Ox transpose' },    // f5\r\n      { pos: 52, score: -1, freq: 0.1, win: 0.48, comment: 'Ox passive' },     // e7\r\n    ]);\r\n\r\n    // Add deeper sequences for main lines\r\n    this.addDeepSequences();\r\n\r\n    // Add named sequences\r\n    this.addNamedSequences();\r\n  }\r\n\r\n  /**\r\n   * Add deeper opening sequences (6-12 moves)\r\n   */\r\n  private addDeepSequences(): void {\r\n    // Tiger main line continuation\r\n    this.addOpening('eeeeeeeeeeeeeeeeee11eeeeeee11111100eeeeeeeeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 10, score: 3, freq: 0.5, win: 0.55, comment: 'Tiger sharp' },     // c2\r\n      { pos: 12, score: 2, freq: 0.3, win: 0.53, comment: 'Tiger solid' },     // e2\r\n      { pos: 25, score: 1, freq: 0.2, win: 0.51, comment: 'Tiger positional' }, // b4\r\n    ]);\r\n\r\n    // Advanced middle game transitions\r\n    this.addOpening('eeeeeeee11eeeeeeee11eeeeeee11111100eeeeeeeeeeeeeeeeeeeeeeeeeeee', [\r\n      { pos: 9, score: 2, freq: 0.4, win: 0.54, comment: 'Advanced tiger' },   // b2\r\n      { pos: 17, score: 2, freq: 0.3, win: 0.53, comment: 'Edge control' },    // b3\r\n      { pos: 24, score: 1, freq: 0.3, win: 0.52, comment: 'Center play' },     // a4\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Add named opening sequences\r\n   */\r\n  private addNamedSequences(): void {\r\n    this._sequences.push(\r\n      {\r\n        name: 'Tiger Opening',\r\n        description: 'Aggressive opening focusing on quick development',\r\n        moves: [19, 18, 10], // d3, c3, c2\r\n        evaluation: 2,\r\n        isMainLine: true,\r\n      },\r\n      {\r\n        name: 'Rabbit Opening',\r\n        description: 'Balanced opening with flexible development',\r\n        moves: [26, 18, 19], // c4, c3, d3\r\n        evaluation: 1,\r\n        isMainLine: true,\r\n      },\r\n      {\r\n        name: 'Cat Defense',\r\n        description: 'Solid defensive setup',\r\n        moves: [37, 45, 43], // f5, f6, d6\r\n        evaluation: 1,\r\n        isMainLine: true,\r\n      },\r\n      {\r\n        name: 'Ox System',\r\n        description: 'Conservative approach with emphasis on stability',\r\n        moves: [44, 43, 45], // e6, d6, f6\r\n        evaluation: 0,\r\n        isMainLine: true,\r\n      },\r\n      {\r\n        name: 'Buffalo Opening',\r\n        description: 'Hypermodern approach delaying central confrontation',\r\n        moves: [19, 20, 12], // d3, e3, e2\r\n        evaluation: 1,\r\n        isMainLine: false,\r\n      },\r\n      {\r\n        name: 'Snake Variation',\r\n        description: 'Provocative opening leading to complex positions',\r\n        moves: [26, 25, 33], // c4, b4, b5\r\n        evaluation: 0,\r\n        isMainLine: false,\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Helper method to add opening positions\r\n   */\r\n  private addOpening(\r\n    boardString: string,\r\n    moves: Array<{ pos: number; score: number; freq: number; win: number; comment?: string }>\r\n  ): void {\r\n    const entries: OpeningEntry[] = moves.map(move => ({\r\n      position: move.pos,\r\n      score: move.score,\r\n      frequency: move.freq,\r\n      winRate: move.win,\r\n      depth: this.calculateDepth(boardString),\r\n      comment: move.comment,\r\n    }));\r\n\r\n    this._entries.set(boardString, entries);\r\n  }\r\n\r\n  /**\r\n   * Generate position key from game state\r\n   */\r\n  private generateKey(gameState: GameState): string {\r\n    // Convert board to string representation\r\n    // 'e' = empty, '1' = black, '2' = white\r\n    return Array.from(gameState.board).map(cell => {\r\n      switch (cell) {\r\n        case PlayerColor.EMPTY: return 'e';\r\n        case PlayerColor.BLACK: return '1';\r\n        case PlayerColor.WHITE: return '2';\r\n        default: return 'e';\r\n      }\r\n    }).join('');\r\n  }\r\n\r\n  /**\r\n   * Calculate opening depth from board string\r\n   */\r\n  private calculateDepth(boardString: string): number {\r\n    const pieceCount = boardString.split('').filter(c => c !== 'e').length;\r\n    return Math.max(0, pieceCount - 4); // Subtract initial 4 pieces\r\n  }\r\n\r\n  /**\r\n   * Export opening statistics\r\n   */\r\n  getStatistics(): {\r\n    totalPositions: number;\r\n    maxDepth: number;\r\n    averageWinRate: number;\r\n    sequenceCount: number;\r\n  } {\r\n    const totalPositions = this._entries.size;\r\n    let totalWinRate = 0;\r\n    let entryCount = 0;\r\n\r\n    for (const entries of this._entries.values()) {\r\n      for (const entry of entries) {\r\n        totalWinRate += entry.winRate;\r\n        entryCount++;\r\n      }\r\n    }\r\n\r\n    return {\r\n      totalPositions,\r\n      maxDepth: this._maxDepth,\r\n      averageWinRate: entryCount > 0 ? totalWinRate / entryCount : 0,\r\n      sequenceCount: this._sequences.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate opening book integrity\r\n   */\r\n  validateBook(): { isValid: boolean; errors: string[] } {\r\n    const errors: string[] = [];\r\n\r\n    // Check for duplicate entries\r\n    for (const [key, entries] of this._entries.entries()) {\r\n      const positions = new Set<BoardPosition>();\r\n      for (const entry of entries) {\r\n        if (positions.has(entry.position)) {\r\n          errors.push(`Duplicate position ${entry.position} in key ${key}`);\r\n        }\r\n        positions.add(entry.position);\r\n\r\n        // Validate entry values\r\n        if (entry.frequency < 0 || entry.frequency > 1) {\r\n          errors.push(`Invalid frequency for position ${entry.position}: ${entry.frequency}`);\r\n        }\r\n        if (entry.winRate < 0 || entry.winRate > 1) {\r\n          errors.push(`Invalid win rate for position ${entry.position}: ${entry.winRate}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate sequences\r\n    for (const sequence of this._sequences) {\r\n      if (sequence.moves.length === 0) {\r\n        errors.push(`Empty sequence: ${sequence.name}`);\r\n      }\r\n      for (const move of sequence.moves) {\r\n        if (move < 0 || move >= 64) {\r\n          errors.push(`Invalid move ${move} in sequence ${sequence.name}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Default opening book instance\r\n */\r\nexport const defaultOpeningBook = new OpeningBook();\r\n\r\n/**\r\n * Factory functions for creating opening books\r\n */\r\nexport const createOpeningBook = {\r\n  /**\r\n   * Create standard opening book\r\n   */\r\n  standard(): OpeningBook {\r\n    return new OpeningBook(12);\r\n  },\r\n\r\n  /**\r\n   * Create extended opening book with deeper analysis\r\n   */\r\n  extended(): OpeningBook {\r\n    return new OpeningBook(16);\r\n  },\r\n\r\n  /**\r\n   * Create minimal opening book for faster lookup\r\n   */\r\n  minimal(): OpeningBook {\r\n    return new OpeningBook(8);\r\n  },\r\n};","/**\r\n * Endgame Solver\r\n *\r\n * Provides perfect play in endgame positions using:\r\n * - Exact minimax search when few squares remain\r\n * - Efficient move generation and evaluation\r\n * - Parity analysis for optimal timing\r\n * - Transposition tables for performance\r\n */\r\n\r\nimport { PlayerColor, BoardPosition } from '@/types/game-types';\r\nimport type { SimulatedGameState } from '../game-simulator';\r\nimport { GameSimulator } from '../game-simulator';\r\n\r\n/**\r\n * Endgame search result\r\n */\r\nexport interface EndgameResult {\r\n  readonly bestMove: BoardPosition;\r\n  readonly exactScore: number;      // Exact final score difference\r\n  readonly movesToEnd: number;      // Number of moves until game end\r\n  readonly isWin: boolean;          // True if position is winning\r\n  readonly nodesSearched: number;   // Performance metric\r\n  readonly timeElapsed: number;     // Time taken for calculation\r\n  readonly confidence: number;      // Always 1.0 for exact solutions\r\n}\r\n\r\n/**\r\n * Endgame solver configuration\r\n */\r\nexport interface EndgameSolverConfig {\r\n  maxEmptySquares: number;          // Solve when <= this many empty squares\r\n  useTranspositionTable: boolean;   // Cache results\r\n  useMoveOrdering: boolean;         // Order moves for better pruning\r\n  maxTimeMs: number;               // Maximum solving time\r\n  enableParity: boolean;           // Use parity analysis\r\n}\r\n\r\n/**\r\n * Endgame transposition table entry\r\n */\r\ninterface EndgameTransposition {\r\n  exactScore: number;\r\n  depth: number;\r\n  bestMove?: BoardPosition;\r\n  flag: 'exact' | 'lower' | 'upper';\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * Endgame Solver Implementation\r\n */\r\nexport class EndgameSolver {\r\n  private readonly _config: EndgameSolverConfig;\r\n  private readonly _transpositionTable = new Map<string, EndgameTransposition>();\r\n  private _nodesSearched = 0;\r\n  private _startTime = 0;\r\n  private _timeLimit = 0;\r\n\r\n  constructor(config: Partial<EndgameSolverConfig> = {}) {\r\n    this._config = {\r\n      maxEmptySquares: 16,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      maxTimeMs: 30000, // 30 seconds max\r\n      enableParity: true,\r\n      ...config,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Solve endgame position exactly\r\n   */\r\n  async solvePosition(\r\n    gameState: SimulatedGameState,\r\n    player: PlayerColor,\r\n    timeLimit?: number,\r\n  ): Promise<EndgameResult> {\r\n    this._startTime = Date.now();\r\n    this._timeLimit = timeLimit || this._config.maxTimeMs;\r\n    this._nodesSearched = 0;\r\n\r\n    // Verify this is an endgame position\r\n    const emptySquares = this.countEmptySquares(gameState.board);\r\n    if (emptySquares > this._config.maxEmptySquares) {\r\n      throw new Error(`Position has ${emptySquares} empty squares, exceeds maximum of ${this._config.maxEmptySquares}`);\r\n    }\r\n\r\n    const result = await this.exactSearch(gameState, player, emptySquares, -64, 64);\r\n\r\n    const timeElapsed = Date.now() - this._startTime;\r\n\r\n    if (!result.bestMove && result.bestMove !== 0) {\r\n      throw new Error('No valid move found in endgame position');\r\n    }\r\n\r\n    return {\r\n      bestMove: result.bestMove,\r\n      exactScore: result.score,\r\n      movesToEnd: emptySquares,\r\n      isWin: result.score > 0,\r\n      nodesSearched: this._nodesSearched,\r\n      timeElapsed,\r\n      confidence: 1.0, // Exact solution\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if position qualifies for endgame solving\r\n   */\r\n  canSolve(gameState: SimulatedGameState): boolean {\r\n    const emptySquares = this.countEmptySquares(gameState.board);\r\n    return emptySquares <= this._config.maxEmptySquares;\r\n  }\r\n\r\n  /**\r\n   * Exact minimax search for endgame\r\n   */\r\n  private async exactSearch(\r\n    gameState: SimulatedGameState,\r\n    originalPlayer: PlayerColor,\r\n    depth: number,\r\n    alpha: number,\r\n    beta: number,\r\n  ): Promise<{ score: number; bestMove?: BoardPosition }> {\r\n    this._nodesSearched++;\r\n\r\n    // Check time limit\r\n    if (Date.now() - this._startTime >= this._timeLimit) {\r\n      throw new Error('Endgame solver timeout');\r\n    }\r\n\r\n    // Check transposition table\r\n    if (this._config.useTranspositionTable) {\r\n      const ttResult = this.lookupTransposition(gameState, depth);\r\n      if (ttResult) {\r\n        return { score: ttResult.exactScore, bestMove: ttResult.bestMove };\r\n      }\r\n    }\r\n\r\n    // Terminal position - calculate exact final score\r\n    if (gameState.gameOver || gameState.validMoves.size === 0) {\r\n      const finalScore = this.calculateFinalScore(gameState, originalPlayer);\r\n      return { score: finalScore };\r\n    }\r\n\r\n    // Get ordered moves\r\n    const moves = this.getOrderedMoves(gameState);\r\n    let bestMove: BoardPosition | undefined;\r\n    let bestScore = gameState.currentPlayer === originalPlayer ? -64 : 64;\r\n\r\n    for (const move of moves) {\r\n      const newState = GameSimulator.makeMove(gameState, move);\r\n      if (!newState) continue;\r\n\r\n      // Handle pass if no valid moves for next player\r\n      let nextState = newState;\r\n      if (nextState.validMoves.size === 0 && !nextState.gameOver) {\r\n        nextState = GameSimulator.makePass(nextState);\r\n      }\r\n\r\n      const result = await this.exactSearch(\r\n        nextState,\r\n        originalPlayer,\r\n        depth - 1,\r\n        alpha,\r\n        beta,\r\n      );\r\n\r\n      // Update best score and alpha-beta bounds\r\n      if (gameState.currentPlayer === originalPlayer) {\r\n        // Maximizing player\r\n        if (result.score > bestScore) {\r\n          bestScore = result.score;\r\n          bestMove = move;\r\n        }\r\n        alpha = Math.max(alpha, bestScore);\r\n      } else {\r\n        // Minimizing player\r\n        if (result.score < bestScore) {\r\n          bestScore = result.score;\r\n          bestMove = move;\r\n        }\r\n        beta = Math.min(beta, bestScore);\r\n      }\r\n\r\n      // Alpha-beta pruning\r\n      if (beta <= alpha) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Store in transposition table\r\n    if (this._config.useTranspositionTable) {\r\n      this.storeTransposition(gameState, depth, bestScore, bestMove, alpha, beta);\r\n    }\r\n\r\n    return { score: bestScore, bestMove };\r\n  }\r\n\r\n  /**\r\n   * Calculate exact final score (difference in piece count)\r\n   */\r\n  private calculateFinalScore(gameState: SimulatedGameState, originalPlayer: PlayerColor): number {\r\n    let playerPieces = 0;\r\n    let opponentPieces = 0;\r\n    let emptySquares = 0;\r\n\r\n    for (let i = 0; i < gameState.board.length; i++) {\r\n      const piece = gameState.board[i];\r\n      if (piece === originalPlayer) {\r\n        playerPieces++;\r\n      } else if (piece !== PlayerColor.EMPTY) {\r\n        opponentPieces++;\r\n      } else {\r\n        emptySquares++;\r\n      }\r\n    }\r\n\r\n    // In endgame, empty squares go to the player who made the last move\r\n    if (emptySquares > 0) {\r\n      // Use parity to determine who gets the empty squares\r\n      if (this._config.enableParity) {\r\n        const parityAdvantage = this.calculateParity(gameState, originalPlayer);\r\n        if (parityAdvantage > 0) {\r\n          playerPieces += emptySquares;\r\n        } else {\r\n          opponentPieces += emptySquares;\r\n        }\r\n      } else {\r\n        // Simple heuristic: current player gets remaining squares\r\n        if (gameState.currentPlayer === originalPlayer) {\r\n          playerPieces += emptySquares;\r\n        } else {\r\n          opponentPieces += emptySquares;\r\n        }\r\n      }\r\n    }\r\n\r\n    return playerPieces - opponentPieces;\r\n  }\r\n\r\n  /**\r\n   * Calculate parity advantage (who is likely to get the last move)\r\n   */\r\n  private calculateParity(gameState: SimulatedGameState, player: PlayerColor): number {\r\n    const emptySquares = this.countEmptySquares(gameState.board);\r\n    const currentPlayerAdvantage = gameState.currentPlayer === player ? 1 : -1;\r\n\r\n    // In positions with odd number of empty squares, current player has advantage\r\n    if (emptySquares % 2 === 1) {\r\n      return currentPlayerAdvantage;\r\n    } else {\r\n      return -currentPlayerAdvantage;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get ordered moves for better alpha-beta pruning\r\n   */\r\n  private getOrderedMoves(gameState: SimulatedGameState): BoardPosition[] {\r\n    const moves = Array.from(gameState.validMoves.keys());\r\n\r\n    if (!this._config.useMoveOrdering) {\r\n      return moves;\r\n    }\r\n\r\n    // Order moves by strategic value in endgame\r\n    const scoredMoves = moves.map(move => {\r\n      let score = 0;\r\n\r\n      // Prioritize corner moves\r\n      if ([0, 7, 56, 63].includes(move)) {\r\n        score += 1000;\r\n      }\r\n\r\n      // Prioritize edge moves\r\n      const row = Math.floor(move / 8);\r\n      const col = move % 8;\r\n      if (row === 0 || row === 7 || col === 0 || col === 7) {\r\n        score += 100;\r\n      }\r\n\r\n      // Prioritize moves that flip more pieces\r\n      const flippedCount = gameState.validMoves.get(move)?.length || 0;\r\n      score += flippedCount * 10;\r\n\r\n      // Avoid X-squares unless necessary\r\n      if ([9, 14, 49, 54].includes(move)) {\r\n        score -= 500;\r\n      }\r\n\r\n      return { move, score };\r\n    });\r\n\r\n    // Sort by score descending\r\n    scoredMoves.sort((a, b) => b.score - a.score);\r\n\r\n    return scoredMoves.map(item => item.move);\r\n  }\r\n\r\n  /**\r\n   * Count empty squares on board\r\n   */\r\n  private countEmptySquares(board: Uint8Array): number {\r\n    let count = 0;\r\n    for (let i = 0; i < board.length; i++) {\r\n      if (board[i] === PlayerColor.EMPTY) {\r\n        count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Generate transposition table key\r\n   */\r\n  private generateTranspositionKey(gameState: SimulatedGameState): string {\r\n    return Array.from(gameState.board).join('') + '_' + gameState.currentPlayer;\r\n  }\r\n\r\n  /**\r\n   * Lookup transposition table\r\n   */\r\n  private lookupTransposition(\r\n    gameState: SimulatedGameState,\r\n    depth: number,\r\n  ): EndgameTransposition | null {\r\n    const key = this.generateTranspositionKey(gameState);\r\n    const entry = this._transpositionTable.get(key);\r\n\r\n    if (entry && entry.depth >= depth) {\r\n      return entry;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Store result in transposition table\r\n   */\r\n  private storeTransposition(\r\n    gameState: SimulatedGameState,\r\n    depth: number,\r\n    score: number,\r\n    bestMove: BoardPosition | undefined,\r\n    alpha: number,\r\n    beta: number,\r\n  ): void {\r\n    const key = this.generateTranspositionKey(gameState);\r\n\r\n    let flag: 'exact' | 'lower' | 'upper';\r\n    if (score <= alpha) {\r\n      flag = 'upper';\r\n    } else if (score >= beta) {\r\n      flag = 'lower';\r\n    } else {\r\n      flag = 'exact';\r\n    }\r\n\r\n    this._transpositionTable.set(key, {\r\n      exactScore: score,\r\n      depth,\r\n      bestMove,\r\n      flag,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    // Limit table size\r\n    if (this._transpositionTable.size > 50000) {\r\n      this.cleanupTranspositionTable();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old transposition table entries\r\n   */\r\n  private cleanupTranspositionTable(): void {\r\n    const cutoff = Date.now() - 600000; // 10 minutes\r\n    for (const [key, entry] of this._transpositionTable.entries()) {\r\n      if (entry.timestamp < cutoff) {\r\n        this._transpositionTable.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get solver statistics\r\n   */\r\n  getStatistics(): {\r\n    transpositionEntries: number;\r\n    maxEmptySquares: number;\r\n    averageNodesPerSecond: number;\r\n  } {\r\n    const timeElapsed = Date.now() - this._startTime;\r\n    const nodesPerSecond = timeElapsed > 0 ? (this._nodesSearched / timeElapsed) * 1000 : 0;\r\n\r\n    return {\r\n      transpositionEntries: this._transpositionTable.size,\r\n      maxEmptySquares: this._config.maxEmptySquares,\r\n      averageNodesPerSecond: nodesPerSecond,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all caches\r\n   */\r\n  clearCaches(): void {\r\n    this._transpositionTable.clear();\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  setConfig(config: Partial<EndgameSolverConfig>): void {\r\n    Object.assign(this._config, config);\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): EndgameSolverConfig {\r\n    return { ...this._config };\r\n  }\r\n}\r\n\r\n/**\r\n * Default endgame solver instance\r\n */\r\nexport const defaultEndgameSolver = new EndgameSolver();\r\n\r\n/**\r\n * Factory functions for creating endgame solvers\r\n */\r\nexport const createEndgameSolver = {\r\n  /**\r\n   * Fast solver for quick endgames\r\n   */\r\n  fast(): EndgameSolver {\r\n    return new EndgameSolver({\r\n      maxEmptySquares: 12,\r\n      maxTimeMs: 5000,\r\n      useMoveOrdering: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Deep solver for thorough analysis\r\n   */\r\n  deep(): EndgameSolver {\r\n    return new EndgameSolver({\r\n      maxEmptySquares: 20,\r\n      maxTimeMs: 60000,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      enableParity: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Tournament solver for competitive play\r\n   */\r\n  tournament(): EndgameSolver {\r\n    return new EndgameSolver({\r\n      maxEmptySquares: 16,\r\n      maxTimeMs: 30000,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      enableParity: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Custom configuration\r\n   */\r\n  custom(config: Partial<EndgameSolverConfig>): EndgameSolver {\r\n    return new EndgameSolver(config);\r\n  },\r\n};","/**\r\n * Advanced AI Strategy\r\n *\r\n * Master-level AI that combines multiple techniques:\r\n * - Opening book for theoretical play\r\n * - Minimax with alpha-beta pruning for midgame\r\n * - Endgame solver for perfect endplay\r\n * - Adaptive time management\r\n * - Monte Carlo Tree Search for complex positions\r\n */\r\n\r\nimport { AIDifficulty, PlayerColor, BoardPosition } from '@/types/game-types';\r\nimport type { GameState } from '@/core/models/GameState';\r\nimport { AIStrategyBase, type AIMoveResult } from '../ai-strategy-base';\r\nimport { MinimaxAI, type MinimaxConfig } from './minimax-ai';\r\nimport { OpeningBook, defaultOpeningBook } from './opening-book';\r\nimport { EndgameSolver, defaultEndgameSolver } from './endgame-solver';\r\nimport { GameSimulator, type SimulatedGameState } from '../game-simulator';\r\nimport { AdvancedEvaluator } from './evaluation';\r\n\r\n/**\r\n * Advanced AI configuration\r\n */\r\nexport interface AdvancedAIConfig {\r\n  // Opening book settings\r\n  useOpeningBook: boolean;\r\n  openingBookDepth: number;\r\n\r\n  // Midgame minimax settings\r\n  minimaxDepth: number;\r\n  minimaxTimeLimit: number;\r\n  useIterativeDeepening: boolean;\r\n\r\n  // Endgame solver settings\r\n  useEndgameSolver: boolean;\r\n  endgameThreshold: number; // Empty squares to trigger endgame\r\n  endgameTimeLimit: number;\r\n\r\n  // Adaptive settings\r\n  adaptiveTimeManagement: boolean;\r\n  thinkingTimeBase: number; // Base thinking time in ms\r\n  thinkingTimeMax: number;  // Maximum thinking time in ms\r\n\r\n  // Advanced features\r\n  useMonteCarlo: boolean;\r\n  monteCarloSamples: number;\r\n  useAspirationWindows: boolean;\r\n}\r\n\r\n/**\r\n * Game phase detection\r\n */\r\ntype GamePhase = 'opening' | 'midgame' | 'endgame';\r\n\r\n/**\r\n * Advanced AI Strategy Implementation\r\n */\r\nexport class AdvancedAI extends AIStrategyBase {\r\n  public readonly difficulty = AIDifficulty.ADVANCED;\r\n  public readonly name = 'Advanced AI';\r\n  public readonly description = 'Master-level AI combining opening book, minimax, and endgame solver';\r\n\r\n  private readonly _config: AdvancedAIConfig;\r\n  private readonly _openingBook: OpeningBook;\r\n  private readonly _endgameSolver: EndgameSolver;\r\n  private _minimaxAI: MinimaxAI;\r\n\r\n  // Performance tracking\r\n  private _phaseStats = {\r\n    opening: { moves: 0, totalTime: 0 },\r\n    midgame: { moves: 0, totalTime: 0 },\r\n    endgame: { moves: 0, totalTime: 0 },\r\n  };\r\n\r\n  constructor(config: Partial<AdvancedAIConfig> = {}) {\r\n    super();\r\n\r\n    this._config = {\r\n      // Opening book\r\n      useOpeningBook: true,\r\n      openingBookDepth: 12,\r\n\r\n      // Midgame minimax\r\n      minimaxDepth: 8,\r\n      minimaxTimeLimit: 5000,\r\n      useIterativeDeepening: true,\r\n\r\n      // Endgame solver\r\n      useEndgameSolver: true,\r\n      endgameThreshold: 16,\r\n      endgameTimeLimit: 30000,\r\n\r\n      // Adaptive time management\r\n      adaptiveTimeManagement: true,\r\n      thinkingTimeBase: 1000,\r\n      thinkingTimeMax: 10000,\r\n\r\n      // Advanced features\r\n      useMonteCarlo: false, // Disabled for now\r\n      monteCarloSamples: 1000,\r\n      useAspirationWindows: true,\r\n\r\n      ...config,\r\n    };\r\n\r\n    this._openingBook = defaultOpeningBook;\r\n    this._endgameSolver = defaultEndgameSolver;\r\n\r\n    // Configure minimax AI\r\n    const minimaxConfig: Partial<MinimaxConfig> = {\r\n      maxDepth: this._config.minimaxDepth,\r\n      maxTime: this._config.minimaxTimeLimit,\r\n      useIterativeDeepening: this._config.useIterativeDeepening,\r\n      useTranspositionTable: true,\r\n      useMoveOrdering: true,\r\n      aspirationWindow: this._config.useAspirationWindows ? 50 : undefined,\r\n    };\r\n\r\n    this._minimaxAI = new MinimaxAI(minimaxConfig);\r\n  }\r\n\r\n  protected async selectMoveImpl(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    const startTime = Date.now();\r\n    const phase = this.detectGamePhase(gameState);\r\n    const adaptiveTimeLimit = this.calculateAdaptiveTimeLimit(gameState, timeLimit, phase);\r\n\r\n    let result: AIMoveResult;\r\n\r\n    try {\r\n      switch (phase) {\r\n        case 'opening':\r\n          result = await this.handleOpening(gameState, player, adaptiveTimeLimit);\r\n          break;\r\n\r\n        case 'midgame':\r\n          result = await this.handleMidgame(gameState, player, adaptiveTimeLimit);\r\n          break;\r\n\r\n        case 'endgame':\r\n          result = await this.handleEndgame(gameState, player, adaptiveTimeLimit);\r\n          break;\r\n\r\n        default:\r\n          result = await this.handleMidgame(gameState, player, adaptiveTimeLimit);\r\n      }\r\n\r\n      // Update performance statistics\r\n      const actualTime = Date.now() - startTime;\r\n      this._phaseStats[phase].moves++;\r\n      this._phaseStats[phase].totalTime += actualTime;\r\n\r\n      // Enhance result with phase information\r\n      return {\r\n        ...result,\r\n        thinkingTime: actualTime,\r\n      };\r\n\r\n    } catch (error) {\r\n      // Fallback to minimax if any component fails\r\n      console.warn(`Advanced AI ${phase} phase failed, falling back to minimax:`, error);\r\n      return this._minimaxAI.selectMove(gameState, player, adaptiveTimeLimit);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle opening phase using opening book\r\n   */\r\n  private async handleOpening(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    if (this._config.useOpeningBook && this._openingBook.hasOpeningMove(gameState)) {\r\n      const openingMove = this._openingBook.getOpeningMove(gameState);\r\n\r\n      if (openingMove !== null) {\r\n        // Simulate thinking time for opening book moves\r\n        const thinkingTime = 200 + Math.random() * 300; // 200-500ms\r\n        await new Promise(resolve => setTimeout(resolve, thinkingTime));\r\n\r\n        return {\r\n          position: openingMove,\r\n          confidence: 0.9, // High confidence in opening theory\r\n          evaluation: 0, // Opening moves are theoretical\r\n          thinkingTime,\r\n          depth: this._openingBook.getOpeningDepth(gameState),\r\n          nodesEvaluated: 1,\r\n        };\r\n      }\r\n    }\r\n\r\n    // Fall back to minimax if no opening book move\r\n    return this._minimaxAI.selectMove(gameState, player, timeLimit);\r\n  }\r\n\r\n  /**\r\n   * Handle midgame using minimax with advanced evaluation\r\n   */\r\n  private async handleMidgame(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    // Use the full minimax AI for midgame\r\n    return this._minimaxAI.selectMove(gameState, player, timeLimit);\r\n  }\r\n\r\n  /**\r\n   * Handle endgame using exact solver\r\n   */\r\n  private async handleEndgame(\r\n    gameState: GameState,\r\n    player: PlayerColor,\r\n    timeLimit: number,\r\n  ): Promise<AIMoveResult> {\r\n    if (!this._config.useEndgameSolver) {\r\n      return this._minimaxAI.selectMove(gameState, player, timeLimit);\r\n    }\r\n\r\n    const simState = GameSimulator.fromGameState(gameState);\r\n\r\n    if (this._endgameSolver.canSolve(simState)) {\r\n      try {\r\n        const endgameResult = await this._endgameSolver.solvePosition(\r\n          simState,\r\n          player,\r\n          Math.min(timeLimit, this._config.endgameTimeLimit),\r\n        );\r\n\r\n        return {\r\n          position: endgameResult.bestMove,\r\n          confidence: endgameResult.confidence,\r\n          evaluation: endgameResult.exactScore,\r\n          thinkingTime: endgameResult.timeElapsed,\r\n          depth: endgameResult.movesToEnd,\r\n          nodesEvaluated: endgameResult.nodesSearched,\r\n        };\r\n      } catch (error) {\r\n        console.warn('Endgame solver failed, falling back to minimax:', error);\r\n      }\r\n    }\r\n\r\n    // Fall back to deep minimax search\r\n    const deepMinimaxConfig = {\r\n      maxDepth: this._config.minimaxDepth + 2, // Extra depth for endgame\r\n      maxTime: timeLimit,\r\n      useIterativeDeepening: true,\r\n    };\r\n\r\n    const deepMinimax = new MinimaxAI(deepMinimaxConfig);\r\n    return deepMinimax.selectMove(gameState, player, timeLimit);\r\n  }\r\n\r\n  /**\r\n   * Detect current game phase\r\n   */\r\n  private detectGamePhase(gameState: GameState): GamePhase {\r\n    const totalPieces = gameState.scores.black + gameState.scores.white;\r\n    const emptySquares = 64 - totalPieces;\r\n\r\n    // Opening phase: first 8-12 moves\r\n    if (totalPieces <= 12) {\r\n      return 'opening';\r\n    }\r\n\r\n    // Endgame phase: 16 or fewer empty squares\r\n    if (emptySquares <= this._config.endgameThreshold) {\r\n      return 'endgame';\r\n    }\r\n\r\n    // Everything else is midgame\r\n    return 'midgame';\r\n  }\r\n\r\n  /**\r\n   * Calculate adaptive thinking time based on position complexity\r\n   */\r\n  private calculateAdaptiveTimeLimit(\r\n    gameState: GameState,\r\n    baseTimeLimit: number,\r\n    phase: GamePhase,\r\n  ): number {\r\n    if (!this._config.adaptiveTimeManagement) {\r\n      return baseTimeLimit;\r\n    }\r\n\r\n    const moveCount = gameState.validMoves.size;\r\n    const complexity = this.assessPositionComplexity(gameState);\r\n\r\n    let timeMultiplier = 1.0;\r\n\r\n    // Phase-based adjustments\r\n    switch (phase) {\r\n      case 'opening':\r\n        timeMultiplier = 0.3; // Quick opening moves\r\n        break;\r\n      case 'midgame':\r\n        timeMultiplier = 1.0; // Standard time\r\n        break;\r\n      case 'endgame':\r\n        timeMultiplier = 2.0; // More time for critical endgame\r\n        break;\r\n    }\r\n\r\n    // Complexity adjustments\r\n    timeMultiplier *= (1.0 + complexity * 0.5);\r\n\r\n    // Move count adjustments (more time when many options)\r\n    if (moveCount > 10) {\r\n      timeMultiplier *= 1.3;\r\n    } else if (moveCount < 3) {\r\n      timeMultiplier *= 0.7;\r\n    }\r\n\r\n    const adaptiveTime = Math.min(\r\n      this._config.thinkingTimeMax,\r\n      Math.max(\r\n        this._config.thinkingTimeBase * timeMultiplier,\r\n        baseTimeLimit * 0.5, // Don't go below 50% of base time\r\n      ),\r\n    );\r\n\r\n    return Math.min(adaptiveTime, baseTimeLimit);\r\n  }\r\n\r\n  /**\r\n   * Assess position complexity for time allocation\r\n   */\r\n  private assessPositionComplexity(gameState: GameState): number {\r\n    let complexity = 0;\r\n\r\n    // More moves = higher complexity\r\n    complexity += Math.min(gameState.validMoves.size / 15, 1.0);\r\n\r\n    // Score difference affects complexity\r\n    const scoreDiff = Math.abs(gameState.scores.black - gameState.scores.white);\r\n    complexity += Math.min(scoreDiff / 20, 0.5);\r\n\r\n    // Corner and edge availability\r\n    const corners = [0, 7, 56, 63];\r\n    const availableCorners = corners.filter(pos => gameState.board[pos] === PlayerColor.EMPTY);\r\n    complexity += availableCorners.length * 0.1;\r\n\r\n    return Math.min(complexity, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): AdvancedAIConfig {\r\n    return { ...this._config };\r\n  }\r\n\r\n  /**\r\n   * Update configuration\r\n   */\r\n  setConfig(config: Partial<AdvancedAIConfig>): void {\r\n    Object.assign(this._config, config);\r\n\r\n    // Update minimax configuration\r\n    const minimaxConfig: Partial<MinimaxConfig> = {\r\n      maxDepth: this._config.minimaxDepth,\r\n      maxTime: this._config.minimaxTimeLimit,\r\n      useIterativeDeepening: this._config.useIterativeDeepening,\r\n      aspirationWindow: this._config.useAspirationWindows ? 50 : undefined,\r\n    };\r\n\r\n    this._minimaxAI.setConfig(minimaxConfig);\r\n  }\r\n\r\n  /**\r\n   * Get performance statistics\r\n   */\r\n  getPerformanceStats(): {\r\n    opening: { moves: number; avgTime: number };\r\n    midgame: { moves: number; avgTime: number };\r\n    endgame: { moves: number; avgTime: number };\r\n    totalMoves: number;\r\n    overallAvgTime: number;\r\n  } {\r\n    const opening = {\r\n      moves: this._phaseStats.opening.moves,\r\n      avgTime: this._phaseStats.opening.moves > 0\r\n        ? this._phaseStats.opening.totalTime / this._phaseStats.opening.moves\r\n        : 0,\r\n    };\r\n\r\n    const midgame = {\r\n      moves: this._phaseStats.midgame.moves,\r\n      avgTime: this._phaseStats.midgame.moves > 0\r\n        ? this._phaseStats.midgame.totalTime / this._phaseStats.midgame.moves\r\n        : 0,\r\n    };\r\n\r\n    const endgame = {\r\n      moves: this._phaseStats.endgame.moves,\r\n      avgTime: this._phaseStats.endgame.moves > 0\r\n        ? this._phaseStats.endgame.totalTime / this._phaseStats.endgame.moves\r\n        : 0,\r\n    };\r\n\r\n    const totalMoves = opening.moves + midgame.moves + endgame.moves;\r\n    const totalTime = this._phaseStats.opening.totalTime +\r\n                      this._phaseStats.midgame.totalTime +\r\n                      this._phaseStats.endgame.totalTime;\r\n\r\n    return {\r\n      opening,\r\n      midgame,\r\n      endgame,\r\n      totalMoves,\r\n      overallAvgTime: totalMoves > 0 ? totalTime / totalMoves : 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset performance statistics\r\n   */\r\n  resetStats(): void {\r\n    this._phaseStats = {\r\n      opening: { moves: 0, totalTime: 0 },\r\n      midgame: { moves: 0, totalTime: 0 },\r\n      endgame: { moves: 0, totalTime: 0 },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all caches\r\n   */\r\n  clearCaches(): void {\r\n    this._minimaxAI.clearCaches();\r\n    this._endgameSolver.clearCaches();\r\n  }\r\n}\r\n\r\n/**\r\n * Factory functions for creating advanced AI variants\r\n */\r\nexport const createAdvancedAI = {\r\n  /**\r\n   * Tournament-level AI with balanced settings\r\n   */\r\n  tournament(): AdvancedAI {\r\n    const isMobile = this.isMobileDevice();\r\n\r\n    if (isMobile) {\r\n      console.log('📱 Creating mobile-optimized Tournament AI');\r\n      return new AdvancedAI({\r\n        useOpeningBook: true,\r\n        openingBookDepth: 10,\r\n        minimaxDepth: 6,\r\n        useEndgameSolver: false, // Disable for mobile\r\n        endgameThreshold: 14,\r\n        adaptiveTimeManagement: true,\r\n        thinkingTimeBase: 1500,\r\n        thinkingTimeMax: 6000,\r\n      });\r\n    }\r\n\r\n    return new AdvancedAI({\r\n      useOpeningBook: true,\r\n      openingBookDepth: 12,\r\n      minimaxDepth: 8,\r\n      useEndgameSolver: true,\r\n      endgameThreshold: 16,\r\n      adaptiveTimeManagement: true,\r\n      thinkingTimeBase: 2000,\r\n      thinkingTimeMax: 15000,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Master-level AI with maximum strength\r\n   */\r\n  master(): AdvancedAI {\r\n    // Detect if running on mobile device\r\n    const isMobile = this.isMobileDevice();\r\n\r\n    if (isMobile) {\r\n      console.log('📱 Creating mobile-optimized Master AI');\r\n      return new AdvancedAI({\r\n        useOpeningBook: true,\r\n        openingBookDepth: 12,\r\n        minimaxDepth: 6,\r\n        useEndgameSolver: false, // Disable for mobile performance\r\n        endgameThreshold: 16,\r\n        adaptiveTimeManagement: true,\r\n        thinkingTimeBase: 2000,\r\n        thinkingTimeMax: 8000,\r\n        useAspirationWindows: false, // Disable for mobile\r\n      });\r\n    }\r\n\r\n    return new AdvancedAI({\r\n      useOpeningBook: true,\r\n      openingBookDepth: 16,\r\n      minimaxDepth: 10,\r\n      useEndgameSolver: true,\r\n      endgameThreshold: 20,\r\n      adaptiveTimeManagement: true,\r\n      thinkingTimeBase: 3000,\r\n      thinkingTimeMax: 30000,\r\n      useAspirationWindows: true,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Mobile device detection utility\r\n   */\r\n  isMobileDevice(): boolean {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    const mobileKeywords = ['mobile', 'android', 'iphone', 'ipad', 'ipod', 'blackberry', 'windows phone'];\r\n    const isMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));\r\n    const isSmallScreen = window.innerWidth < 768;\r\n    const hasTouchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\r\n    return isMobileUA || (isSmallScreen && hasTouchSupport);\r\n  },\r\n\r\n  /**\r\n   * Fast AI for quick games\r\n   */\r\n  blitz(): AdvancedAI {\r\n    return new AdvancedAI({\r\n      useOpeningBook: true,\r\n      openingBookDepth: 8,\r\n      minimaxDepth: 6,\r\n      useEndgameSolver: true,\r\n      endgameThreshold: 12,\r\n      adaptiveTimeManagement: false,\r\n      thinkingTimeBase: 500,\r\n      thinkingTimeMax: 2000,\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Custom advanced AI\r\n   */\r\n  custom(config: Partial<AdvancedAIConfig>): AdvancedAI {\r\n    return new AdvancedAI(config);\r\n  },\r\n};","/**\r\n * AI Web Worker\r\n *\r\n * Runs AI computations in a separate thread to prevent main thread blocking\r\n * and maintain smooth animations during AI thinking.\r\n */\r\n\r\n// Import AI strategies\r\nimport { createRandomAI } from '../core/ai/strategies/random-ai';\r\nimport { createGreedyAI } from '../core/ai/strategies/greedy-ai';\r\nimport { createMinimaxAI } from '../core/ai/strategies/minimax-ai';\r\nimport { createAdvancedAI } from '../core/ai/strategies/advanced-ai';\r\nimport { AIDifficulty, PlayerColor } from '../types/game-types';\r\nimport type { GameState } from '../core/models/GameState';\r\nimport type { AIMoveResult } from '../core/ai/ai-strategy-base';\r\n\r\n// Worker message types\r\ninterface WorkerRequest {\r\n  type: 'CALCULATE_MOVE';\r\n  payload: {\r\n    id: string; // Request ID for tracking\r\n    gameState: GameState;\r\n    player: PlayerColor;\r\n    difficulty: AIDifficulty;\r\n    timeLimit: number;\r\n    customConfig?: any;\r\n  };\r\n}\r\n\r\ninterface WorkerResponse {\r\n  type: 'MOVE_RESULT' | 'ERROR';\r\n  payload: {\r\n    id: string;\r\n    result?: AIMoveResult;\r\n    error?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Create AI instance based on difficulty\r\n */\r\nfunction createAI(difficulty: AIDifficulty, customConfig?: any) {\r\n  switch (difficulty) {\r\n    case AIDifficulty.RANDOM:\r\n      return createRandomAI.smart();\r\n\r\n    case AIDifficulty.GREEDY:\r\n      return createGreedyAI.adaptive();\r\n\r\n    case AIDifficulty.MINIMAX_EASY:\r\n      return createMinimaxAI.basic();\r\n\r\n    case AIDifficulty.MINIMAX:\r\n      return createMinimaxAI.intermediate();\r\n\r\n    case AIDifficulty.MINIMAX_HARD:\r\n      return createMinimaxAI.advanced();\r\n\r\n    case AIDifficulty.ADVANCED:\r\n      return createAdvancedAI.tournament();\r\n\r\n    case AIDifficulty.MASTER:\r\n      return createAdvancedAI.master();\r\n\r\n    case AIDifficulty.BLITZ:\r\n      return createAdvancedAI.blitz();\r\n\r\n    case AIDifficulty.CUSTOM:\r\n      if (customConfig) {\r\n        return createAdvancedAI.custom(customConfig);\r\n      }\r\n      return createAdvancedAI.tournament();\r\n\r\n    default:\r\n      return createGreedyAI.standard();\r\n  }\r\n}\r\n\r\n/**\r\n * Main worker message handler\r\n */\r\nself.addEventListener('message', async (event: MessageEvent<WorkerRequest>) => {\r\n  const { type, payload } = event.data;\r\n\r\n  if (type === 'CALCULATE_MOVE') {\r\n    const { id, gameState, player, difficulty, timeLimit, customConfig } = payload;\r\n\r\n    try {\r\n      console.log(`🤖 AI Worker: Starting calculation for ${difficulty} (depth: ${getSearchDepth(difficulty)})`);\r\n\r\n      // Create AI instance\r\n      const ai = createAI(difficulty, customConfig);\r\n\r\n      // Calculate move (this runs in worker thread, won't block main thread)\r\n      const startTime = Date.now();\r\n      const result = await ai.selectMove(gameState, player, timeLimit);\r\n      const actualTime = Date.now() - startTime;\r\n\r\n      console.log(`🤖 AI Worker: Calculation complete in ${actualTime}ms`);\r\n\r\n      // Send result back to main thread\r\n      const response: WorkerResponse = {\r\n        type: 'MOVE_RESULT',\r\n        payload: {\r\n          id,\r\n          result: {\r\n            ...result,\r\n            thinkingTime: actualTime, // Override with actual time\r\n          },\r\n        },\r\n      };\r\n\r\n      self.postMessage(response);\r\n\r\n    } catch (error) {\r\n      console.error('🤖 AI Worker: Error during calculation:', error);\r\n\r\n      // Send error back to main thread\r\n      const response: WorkerResponse = {\r\n        type: 'ERROR',\r\n        payload: {\r\n          id,\r\n          error: error instanceof Error ? error.message : 'Unknown AI error',\r\n        },\r\n      };\r\n\r\n      self.postMessage(response);\r\n    }\r\n  }\r\n});\r\n\r\n/**\r\n * Get search depth for difficulty (for logging)\r\n */\r\nfunction getSearchDepth(difficulty: AIDifficulty): string {\r\n  switch (difficulty) {\r\n    case AIDifficulty.RANDOM: return '0';\r\n    case AIDifficulty.GREEDY: return '1';\r\n    case AIDifficulty.MINIMAX_EASY: return '4';\r\n    case AIDifficulty.MINIMAX: return '6';\r\n    case AIDifficulty.MINIMAX_HARD: return '8';\r\n    case AIDifficulty.ADVANCED: return '8+';\r\n    case AIDifficulty.MASTER: return '10+';\r\n    case AIDifficulty.BLITZ: return '6+';\r\n    case AIDifficulty.CUSTOM: return 'custom';\r\n    default: return 'unknown';\r\n  }\r\n}\r\n\r\n// Worker is ready\r\nconsole.log('🤖 AI Worker: Ready for calculations');"],"names":["PlayerColor","GameStatus","Grade","AIDifficulty","POSITION_VALUES","GRADE_THRESHOLDS","PERFORMANCE_TARGETS","isValidPosition","position","positionToCoords","isCorner","isEdge","coords","isXSquare","AIStrategyBase","gameState","player","timeLimit","startTime","targetTime","result","actualThinkingTime","actualTime","movesPlayed","totalThinkingTime","sum","time","totalNodes","nodes","totalDepth","depth","timeRatio","baseAccuracy","AIUtils","baseScore","jitterAmount","jitter","candidates","temperature","scaledCandidates","candidate","totalWeight","randomValue","cumulativeWeight","stability","row","col","friendlyNeighbors","pos","neighbors","dr","dc","newRow","newCol","_player","RandomAI","_timeLimit","validMoves","thinkingDelay","resolve","randomIndex","selectedPosition","evaluation","flippedPositions","score","SmartRandomAI","cornerMoves","safeEdgeMoves","xSquareMoves","normalMoves","candidateMoves","moveType","confidence","createRandomAI","validateMove","board","calculateFlips","allFlips","opponent","directions","startCoords","direction","flipsInDirection","calculateFlipsInDirection","flips","currentRow","currentCol","currentPosition","currentPiece","getValidMoves","applyMove","newBoard","flipPosition","isCornerMove","isEdgeMove","isXSquareMove","isCSquareMove","calculateMobility","validation","playerMoves","opponentMoves","calculateStability","protectedDirections","dir","neighborPos","evaluateMove","breakdown","calculateScoreBreakdown","grade","calculateGrade","positionValue","calculatePositionValue","flippedCount","stabilityBonus","calculateStabilityBonus","mobilityFactor","calculateMobilityFactor","total","placedStability","flippedPos","flippedStability","mobility","evaluateAllMoves","evaluatedMoves","a","b","getBestMove","bestMove","move","GreedyAI","remainingTime","sortedMoves","scoreGap","EnhancedGreedyAI","enhancedMoves","threshold","topCandidates","selectedMove","gamePhase","AdaptiveGreedyAI","strategy","strategicMoves","selectionTemperature","topMoves","myScore","opponentScore","scoreDifference","_gameState","moveCount","baseTime","createGreedyAI","EVALUATION_WEIGHTS","ADVANCED_POSITION_VALUES","STABILITY_VALUES","AdvancedEvaluator","cornerControl","edgeControl","potentialMobility","parity","material","piece","playerMobility","opponentMobility","playerStability","opponentStability","stabilityValue","stableDirections","pos1","pos2","corners","playerCorners","opponentCorners","corner","playerEdges","opponentEdges","playerPotential","opponentPotential","adjacentToPlayer","adjacentToOpponent","color","adjacent","emptySquares","i","playerPieces","opponentPieces","endgameWeight","quickEvaluate","GameSimulator","gameOver","state","nextPlayer","newScores","nextValidMoves","newConsecutivePasses","afterPassPlayer","afterPassMoves","black","white","moves","newState","occupiedSquares","state1","state2","empty","calculatedScores","MinimaxAI","config","effectiveTimeLimit","searchResult","bestResult","lastScore","aspirationAlpha","aspirationBeta","widerResult","alpha","beta","isMaximizing","originalPlayer","ttEntry","simState","evalState","bestScore","newGameState","bonus","historyKey","historyScore","item","killers","key","entry","flag","cutoff","createMinimaxAI","OpeningBook","maxDepth","entries","validEntries","best","current","bestValue","name","seq","boardString","cell","pieceCount","c","totalPositions","totalWinRate","entryCount","errors","positions","sequence","defaultOpeningBook","EndgameSolver","timeElapsed","ttResult","nextState","currentPlayerAdvantage","scoredMoves","count","nodesPerSecond","defaultEndgameSolver","AdvancedAI","minimaxConfig","phase","adaptiveTimeLimit","openingMove","thinkingTime","endgameResult","deepMinimaxConfig","totalPieces","baseTimeLimit","complexity","timeMultiplier","adaptiveTime","scoreDiff","availableCorners","opening","midgame","endgame","totalMoves","totalTime","createAdvancedAI","userAgent","isMobileUA","keyword","isSmallScreen","hasTouchSupport","createAI","difficulty","customConfig","event","type","payload","id","ai","response","error"],"mappings":"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"}